<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pymata_express.pymata_express API documentation</title>
<meta name="description" content="Copyright (c) 2018-2020 Alan Yorinks All rights reserved â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pymata_express.pymata_express</code></h1>
</header>
<section id="section-intro">
<p>Copyright (c) 2018-2020 Alan Yorinks All rights reserved.</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
Version 3 as published by the Free Software Foundation; either
or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU
General Public License for more details.</p>
<p>You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301
USA</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
 Copyright (c) 2018-2020 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
&#34;&#34;&#34;

import asyncio
import sys
import time

# noinspection PyPackageRequirementscd
from serial.serialutil import SerialException
# noinspection PyPackageRequirements
from serial.tools import list_ports

from pymata_express.pin_data import PinData
from pymata_express.private_constants import PrivateConstants
from pymata_express.pymata_express_serial import PymataExpressSerial
from pymata_express.pymata_express_socket import PymataExpressSocket


class PymataExpress:
    &#34;&#34;&#34;
    This class exposes and implements the PymataExpress API.
    It includes the public API methods as well as
    a set of private methods. This is an asyncio API

    &#34;&#34;&#34;

    # noinspection PyPep8,PyPep8
    def __init__(self, com_port=None, baud_rate=115200,
                 arduino_instance_id=1, arduino_wait=4,
                 sleep_tune=0.0001, autostart=True,
                 loop=None, shutdown_on_exception=True,
                 close_loop_on_shutdown=True,
                 ip_address=None, ip_port=None,
                 ):
        &#34;&#34;&#34;
        If you are using the Firmata Express Arduino sketch,
        and have a single Arduino connected to your computer,
        then you may accept all the default values.

        If you are using some other Firmata sketch, then
        you must specify both the com_port and baudrate for
        as serial connection, or ip_address and ip_port if
        using StandardFirmataWifi.

        :param com_port: e.g. COM3 or /dev/ttyACM0.

        :param baud_rate: Match this to the Firmata sketch in use.

        :param arduino_instance_id: If you are using the Firmata
                                    Express sketch, match this
                                    value to that in the sketch.

        :param arduino_wait: Amount of time to wait for an Arduino to
                             fully reset itself.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param autostart: If you wish to call the start method within
                          your application, then set this to False.

        :param loop: optional user provided event loop

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :param close_loop_on_shutdown: stop and close the event loop loop
                                       when a shutdown is called or a serial
                                       error occurs

        :param ip_address: When interfacing with StandardFirmataWifi, set the
                           IP address of the device.

        :param ip_port: When interfacing with StandardFirmataWifi, set the
                        ip port of the device.
        &#34;&#34;&#34;
        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if sys.platform == &#39;win32&#39;:
            if python_version[0] &gt; 3:
                if python_version[1] &gt;= 8:
                    if python_version[2] &gt;= 3:
                        pass
                    else:
                        raise RuntimeError(&#34;ERROR: Python 3.8.2 or greater is &#34;
                                           &#34;required for use of this program on Windows.&#34;)

        elif python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters
        self.com_port = com_port
        self.baud_rate = baud_rate
        self.arduino_instance_id = arduino_instance_id
        self.arduino_wait = arduino_wait
        self.sleep_tune = sleep_tune
        self.autostart = autostart
        self.ip_address = ip_address
        self.ip_port = ip_port

        # set the event loop
        if loop is None:
            self.loop = asyncio.get_event_loop()
        else:
            self.loop = loop

        self.shutdown_on_exception = shutdown_on_exception
        self.close_loop_on_shutdown = close_loop_on_shutdown

        # a list of PinData objects - one for each pin segregated by pin type
        # see pin_data.py
        self.analog_pins = []
        self.digital_pins = []

        # serial port in use
        self.serial_port = None

        # reference to tcp/ip socket
        self.sock = None

        # An i2c_map entry consists of a device i2c address as the key, and
        #  the value of the key consists of a dictionary containing 2 entries.
        #  The first entry. &#39;value&#39; contains the last value reported, and
        # the second, &#39;callback&#39; contains a reference to a callback function,
        # and the third, a time-stamp
        # For example:
        # {12345: {&#39;value&#39;: 23, &#39;callback&#39;: None, time_stamp:None}}
        self.i2c_map = {}

        # The active_sonar_map maps the sonar trigger pin number (the key)
        # to the current data value returned
        # if a callback was specified, it is stored in the map as well.
        # A map entry consists of:
        #   pin: [callback, current_data_returned, time_stamp]
        self.active_sonar_map = {}

        # keep alive variables
        self.keep_alive_interval = []
        self.period = 0
        self.margin = 0
        self.keep_alive_task = None

        # first analog pin number
        self.first_analog_pin = None

        # dht error flag
        self.dht_sensor_error = False

        # a list of pins assigned to DHT devices
        self.dht_list = []

        # generic asyncio task holder
        self.the_task = None
        self.the_socket_receive_task = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        # reference to instant of pymata_express_socket
        self.socket_transport = None

        self.using_firmata_express = False

        # this dictionary for mapping incoming Firmata message types to
        # handlers for the messages
        self.command_dictionary = {PrivateConstants.REPORT_VERSION:
                                       self._report_version,
                                   PrivateConstants.REPORT_FIRMWARE:
                                       self._report_firmware,
                                   PrivateConstants.CAPABILITY_RESPONSE:
                                       self._capability_response,
                                   PrivateConstants.ANALOG_MAPPING_RESPONSE:
                                       self._analog_mapping_response,
                                   PrivateConstants.PIN_STATE_RESPONSE:
                                       self._pin_state_response,
                                   PrivateConstants.STRING_DATA:
                                       self._string_data,
                                   PrivateConstants.ANALOG_MESSAGE:
                                       self._analog_message,
                                   PrivateConstants.DIGITAL_MESSAGE:
                                       self._digital_message,
                                   PrivateConstants.I2C_REPLY:
                                       self._i2c_reply,
                                   PrivateConstants.SONAR_DATA:
                                       self._sonar_data,
                                   PrivateConstants.DHT_DATA:
                                       self._dht_read_response,
                                   }

        # report query results are stored in this dictionary
        self.query_reply_data = {PrivateConstants.REPORT_VERSION: &#39;&#39;,
                                 PrivateConstants.STRING_DATA: &#39;&#39;,
                                 PrivateConstants.REPORT_FIRMWARE: &#39;&#39;,
                                 PrivateConstants.CAPABILITY_RESPONSE: None,
                                 PrivateConstants.ANALOG_MAPPING_RESPONSE:
                                     None,
                                 PrivateConstants.PIN_STATE_RESPONSE: None,
                                 PrivateConstants.DHT_DATA: &#39;&#39;,
                                 }

        print(&#39;{}{}{}&#39;.format(&#39;\n&#39;, &#39;Pymata Express Version &#39; +
                              PrivateConstants.PYMATA_EXPRESS_VERSION,
                              &#39;\nCopyright (c) 2018-2020 Alan Yorinks All &#39;
                              &#39;rights reserved.\n&#39;))

        if autostart:
            self.loop.run_until_complete(self.start_aio())

    async def start_aio(self):
        &#34;&#34;&#34;
        This method may be called directly, if the autostart
        parameter in __init__ is set to false.

        This method instantiates the serial interface and then performs auto pin
        discovery if using a serial interface, or creates and connects to
        a TCP/IP enabled device running StandardFirmataWiFi.

        Use this method if you wish to start PymataExpress manually from
        an asyncio function.
         &#34;&#34;&#34;

        # using the serial port
        if not self.ip_address:
            if not self.com_port:
                # user did not specify a com_port
                try:
                    await self._find_arduino()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        await self.shutdown()
            else:
                # com_port specified - set com_port and baud rate
                try:
                    await self._manual_open()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        await self.shutdown()

            if self.com_port:
                print(&#39;{}{}\n&#39;.format(&#39;\nArduino found and connected to &#39;,
                                      self.com_port))

            # no com_port found - raise a runtime exception
            else:
                if self.shutdown_on_exception:
                    await self.shutdown()
                raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)
        # connect to a wifi enabled device server
        else:
            self.socket_transport = PymataExpressSocket(self.ip_address, self.ip_port,
                                                        self.loop)
            await self.socket_transport.start()
            # self.loop.create_task(self.socket_transport.read())

        # start the command dispatcher loop
        if not self.loop:
            self.loop = asyncio.get_event_loop()
        self.the_task = self.loop.create_task(self._arduino_report_dispatcher())

        # get arduino firmware version and print it
        firmware_version = await self.get_firmware_version()
        if not firmware_version:
            print(&#39;*** Firmware Version retrieval timed out. ***&#39;)
            print(&#39;\nDo you have Arduino connectivity and do you have a &#39;)
            print(&#39;Firmata sketch uploaded to the board and are connected&#39;)
            print(&#39;to the correct serial port.\n&#39;)
            print(&#39;To see a list of serial ports, type: &#39;
                  &#39;&#34;list_serial_ports&#34; in your console.&#39;)
            if self.shutdown_on_exception:
                await self.shutdown()
            raise RuntimeError
        else:
            if self.using_firmata_express:
                version_number = firmware_version[0:3]
                if version_number != PrivateConstants.FIRMATA_EXPRESS_VERSION:
                    raise RuntimeError(f&#39;You must use FirmataExpress version 1.2. &#39;
                                       f&#39;Version Found = {version_number}&#39;)
            print(&#34;\nArduino Firmware ID: &#34; + firmware_version)

        # try to get an analog pin map. if it comes back as none - shutdown
        report = await self.get_analog_map()
        if not report:
            print(&#39;*** Analog map retrieval timed out. ***&#39;)
            print(&#39;\nDo you have Arduino connectivity and do you have a &#39;
                  &#39;Firmata sketch uploaded to the board?&#39;)
            if self.shutdown_on_exception:
                await self.shutdown()
            raise RuntimeError

        # custom assemble the pin lists
        for pin in report:
            digital_data = PinData()
            self.digital_pins.append(digital_data)
            if pin != PrivateConstants.IGNORE:
                analog_data = PinData()
                self.analog_pins.append(analog_data)

        print(&#39;{} {} {} {} {}&#39;.format(&#39;Auto-discovery complete. Found&#39;,
                                      len(self.digital_pins),
                                      &#39;Digital Pins and&#39;,
                                      len(self.analog_pins),
                                      &#39;Analog Pins\n\n&#39;))
        self.first_analog_pin = len(self.digital_pins) - len(self.analog_pins)
        await self.set_sampling_interval(19)

    async def get_event_loop(self):
        &#34;&#34;&#34;
        Return the currently active asyncio event loop

        :return: Active event loop

        &#34;&#34;&#34;
        return self.loop

    async def _find_arduino(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for an Arduino
        containing a sketch that has a matching arduino_instance_id as
        specified in the input parameters of this class.

        This is used explicitly with the FirmataExpress sketch.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            # print(&#39;\nChecking {}&#39;.format(port.device))
            try:
                self.serial_port = PymataExpressSerial(port.device, self.baud_rate,
                                                       express_instance=self,
                                                       close_loop_on_error=self.close_loop_on_shutdown)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            serial_ports.append(self.serial_port)

            # display to the user
            print(&#39;\t&#39; + port.device)

            # clear out any possible data in the input buffer
            await self.serial_port.reset_input_buffer()

        # wait for arduino to reset
        print(&#39;\nWaiting {} seconds(arduino_wait) for Arduino devices to &#39;
              &#39;reset...&#39;.format(self.arduino_wait))
        await asyncio.sleep(self.arduino_wait)

        print(&#39;\nSearching for an Arduino configured with an arduino_instance = &#39;,
              self.arduino_instance_id)

        for serial_port in serial_ports:
            self.serial_port = serial_port
            # send the &#34;are you there&#34; sysex request to the arduino
            await self._send_sysex(PrivateConstants.ARE_YOU_THERE)

            # wait until the END_SYSEX comes back
            i_am_here = await self.serial_port.read_until(expected=b&#39;\xf7&#39;)
            if not i_am_here:
                continue

            # make sure we get back the expected length
            if len(i_am_here) != 4:
                continue

            # convert i_am_here to a list
            i_am_here = list(i_am_here)

            # check sysex command is I_AM_HERE
            if i_am_here[1] != PrivateConstants.I_AM_HERE:
                continue
            else:
                # got an I am here message - is it the correct ID?
                if i_am_here[2] == self.arduino_instance_id:
                    self.com_port = serial_port.com_port
                    self.using_firmata_express = True
                    return

    async def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        print(&#39;Opening {} ...&#39;.format(self.com_port))
        self.serial_port = PymataExpressSerial(self.com_port, self.baud_rate,
                                               express_instance=self,
                                               close_loop_on_error=self.close_loop_on_shutdown)

        print(&#39;Waiting {} seconds for the Arduino To Reset.&#39;
              .format(self.arduino_wait))
        await asyncio.sleep(self.arduino_wait)
        if self.baud_rate == 115200:
            await self._send_sysex(PrivateConstants.ARE_YOU_THERE)

            # await asyncio.sleep(1)
            # wait until the END_SYSEX comes back
            i_am_here = await self.serial_port.read_until(expected=b&#39;\xf7&#39;)

            # convert i_am_here to a list
            i_am_here = list(i_am_here)

            if len(i_am_here) != 4:
                raise RuntimeError(&#39;Invalid Arduino ID reply length&#39;)

            # check sysex command is I_AM_HERE
            if i_am_here[1] != PrivateConstants.I_AM_HERE:
                raise RuntimeError(&#39;Retrieving ID From Arduino Failed.&#39;)
            else:
                # got an I am here message - is it the correct ID?
                if i_am_here[2] == self.arduino_instance_id:
                    return
                else:
                    raise RuntimeError(&#39;Invalid Arduino identifier retrieved&#39;)

    async def analog_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified analog pin.

        :param pin: Analog pin number (ex. A2 is specified as 2)

        :returns:  [last value reported, time-stamp]
        &#34;&#34;&#34;

        return self.analog_pins[pin].current_value, self.analog_pins[pin].event_time

    async def analog_write(self, pin, value):
        &#34;&#34;&#34;
        This is an alias for PWM_write

        It may be removed in the future.

        Set the selected pin to the specified value.

        :param pin: Analog output pin number

        :param value: Pin value (0 - 0x4000)

        &#34;&#34;&#34;

        await self.pwm_write(pin, value)

    async def _analog_write_extended(self, pin, data):
        &#34;&#34;&#34;
        This method will send an extended-data analog write command to the
        selected pin.

        :param pin: 0 - 127

        :param data: 0 - 0xfffff

        :returns: No return value
        &#34;&#34;&#34;
        analog_data = [pin, data &amp; 0x7f, (data &gt;&gt; 7) &amp; 0x7f,
                       (data &gt;&gt; 14) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.EXTENDED_ANALOG, analog_data)

    async def digital_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified digital pin.

        :param pin: Digital pin number

        :returns:  [last value reported, time-stamp]

        &#34;&#34;&#34;
        return self.digital_pins[pin].current_value, self.digital_pins[pin].event_time

    async def dht_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified dht pin.

        :param pin: digital pin number

        :return: list = [humidity, temperature  time_stamp]

        &#34;&#34;&#34;
        return self.digital_pins[pin].current_value[0], \
               self.digital_pins[pin].current_value[1], \
               self.digital_pins[pin].event_time

    async def digital_pin_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value directly without port manipulation.

        :param pin: arduino pin number

        :param value: pin value

        &#34;&#34;&#34;

        command = (PrivateConstants.SET_DIGITAL_PIN_VALUE, pin, value)

        await self._send_command(command)

    async def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;
        # The command value is not a fixed value, but needs to be calculated
        # using the pin&#39;s port number
        port = pin // 8

        calculated_command = PrivateConstants.DIGITAL_MESSAGE + port
        mask = 1 &lt;&lt; (pin % 8)
        # Calculate the value for the pin&#39;s position in the port mask
        if value == 1:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] |= mask
        else:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp;= ~mask

        # Assemble the command
        command = (calculated_command,
                   PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp; 0x7f,
                   (PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &gt;&gt; 7)
                   &amp; 0x7f)

        await self._send_command(command)

    async def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for A0, the number is 0.

        &#34;&#34;&#34;
        pin = pin + self.first_analog_pin
        await self.set_pin_mode_digital_input(pin)

    async def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting. By turning reporting off for this pin,
        Reporting is disabled for all 8 bits in the &#34;port&#34;

        :param pin: Pin and all pins for this port

        &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_DISABLE]
        await self._send_command(command)

    async def enable_analog_reporting(self, pin, callback=None, differential=1):
        &#34;&#34;&#34;
        Enables analog reporting. This is an alias for set_pin_mode_analog

        :param pin: Analog pin number. For example for A0, the number is 0.

        :param callback: async callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.
        &#34;&#34;&#34;
        await self.set_pin_mode_analog_input(pin, callback, differential)

    async def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enables digital reporting. By turning reporting on for all 8 bits
        in the &#34;port&#34; - this is part of Firmata&#39;s protocol specification.

        :param pin: Pin and all pins for this port

        :returns: No return value
            &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_ENABLE]
        await self._send_command(command)

    async def get_analog_map(self):
        &#34;&#34;&#34;
        This method requests a Firmata analog map query and returns the
        results.

        :returns: An analog map response or None if a timeout occurs
        &#34;&#34;&#34;
        # get the current time to make sure a report is retrieved
        current_time = time.time()

        # if we do not have existing report results, send a Firmata
        # message to request one
        if self.query_reply_data.get(
                PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
            await self._send_sysex(PrivateConstants.ANALOG_MAPPING_QUERY)
            # wait for the report results to return for 4 seconds
            # if the timer expires, return None
            while self.query_reply_data.get(
                    PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
                elapsed_time = time.time()
                if elapsed_time - current_time &gt; 4:
                    return None
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(
            PrivateConstants.ANALOG_MAPPING_RESPONSE)

    async def get_capability_report(self):
        &#34;&#34;&#34;
        This method requests and returns a Firmata capability query report

        :returns: A capability report in the form of a list
        &#34;&#34;&#34;
        if self.query_reply_data.get(
                PrivateConstants.CAPABILITY_RESPONSE) is None:
            await self._send_sysex(PrivateConstants.CAPABILITY_QUERY)
            while self.query_reply_data.get(
                    PrivateConstants.CAPABILITY_RESPONSE) is None:
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.CAPABILITY_RESPONSE)

    async def get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the Firmata firmware version

        :returns: Firmata firmware version
        &#34;&#34;&#34;
        current_time = time.time()
        if self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
            await self._send_sysex(PrivateConstants.REPORT_FIRMWARE)
            while self.query_reply_data.get(
                    PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
                elapsed_time = time.time()
                if elapsed_time - current_time &gt; 4:
                    return None
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE)

    async def get_protocol_version(self):
        &#34;&#34;&#34;
        This method returns the major and minor values for the protocol
        version, i.e. 2.5

        :returns: Firmata protocol version
        &#34;&#34;&#34;
        if self.query_reply_data.get(PrivateConstants.REPORT_VERSION) == &#39;&#39;:
            await self._send_command([PrivateConstants.REPORT_VERSION])
            while self.query_reply_data.get(
                    PrivateConstants.REPORT_VERSION) == &#39;&#39;:
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.REPORT_VERSION)

    async def get_pin_state(self, pin):
        &#34;&#34;&#34;
        This method retrieves a pin state report for the specified pin.
        Pin modes reported:

        INPUT   = 0x00  # digital input mode

        OUTPUT  = 0x01  # digital output mode

        ANALOG  = 0x02  # analog input mode

        PWM     = 0x03  # digital pin in PWM output mode

        SERVO   = 0x04  # digital pin in Servo output mode

        I2C     = 0x06  # pin included in I2C setup

        STEPPER = 0x08  # digital pin in stepper mode

        PULLUP  = 0x0b  # digital pin in input pullup mode

        SONAR   = 0x0c  # digital pin in SONAR mode

        TONE    = 0x0d  # digital pin in tone mode

        :param pin: Pin of interest

        :returns: pin state report

        &#34;&#34;&#34;
        # place pin in a list to keep _send_sysex happy
        await self._send_sysex(PrivateConstants.PIN_STATE_QUERY, [pin])
        while self.query_reply_data.get(
                PrivateConstants.PIN_STATE_RESPONSE) is None:
            await asyncio.sleep(self.sleep_tune)
        pin_state_report = self.query_reply_data.get(
            PrivateConstants.PIN_STATE_RESPONSE)
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = None
        return pin_state_report

    # noinspection PyMethodMayBeStatic
    async def get_pymata_version(self):
        &#34;&#34;&#34;
        This method retrieves the PyMata Express version number

        :returns: PyMata Express version number.
        &#34;&#34;&#34;
        return PrivateConstants.PYMATA_EXPRESS_VERSION

    async def i2c_read_saved_data(self, address):
        &#34;&#34;&#34;
        This method retrieves cached i2c data to support a polling mode.

        :param address: I2C device address

        :returns data: [raw data returned from i2c device, time-stamp]

        &#34;&#34;&#34;
        if address in self.i2c_map:
            map_entry = self.i2c_map.get(address)
            data = map_entry.get(&#39;value&#39;)
            return data
        else:
            return None

    async def i2c_read(self, address, register, number_of_bytes,
                       callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;

        await self._i2c_read_request(address, register, number_of_bytes,
                                     PrivateConstants.I2C_READ, callback)

    async def i2c_read_continuous(self, address, register, number_of_bytes,
                                  callback=None):
        &#34;&#34;&#34;
        Some i2c devices support a continuous streaming data output.
        This command enables that mode for the device that supports
        continuous reads.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;

        await self._i2c_read_request(address, register, number_of_bytes,
                                     PrivateConstants.I2C_READ_CONTINUOUSLY,
                                     callback)

    async def i2c_read_restart_transmission(self, address, register,
                                            number_of_bytes,
                                            callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device. This restarts the transmission after the read. It is
        required for some i2c devices such as the MMA8452Q accelerometer.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;

        await self._i2c_read_request(address, register, number_of_bytes,
                                     PrivateConstants.I2C_READ
                                     | PrivateConstants.I2C_END_TX_MASK,
                                     callback)

    async def _i2c_read_request(self, address, register, number_of_bytes, read_type,
                                callback=None):
        &#34;&#34;&#34;
        This method requests the read of an i2c device. Results are retrieved
        by a call to i2c_get_read_data(). or by callback.

        If a callback method is provided, when data is received from the
        device it will be sent to the callback method.

        Some devices require that transmission be restarted
        (e.g. MMA8452Q accelerometer).

        I2C_READ | I2C_END_TX_MASK values for the read_type in those cases.

        I2C_READ = 0B00001000

        I2C_READ_CONTINUOUSLY = 0B00010000

        I2C_STOP_READING = 0B00011000

        I2C_END_TX_MASK = 0B01000000

        :param address: i2c device address

        :param register: register number (can be set to zero or None)

        :param number_of_bytes: number of bytes expected to be returned

        :param read_type: I2C_READ  or I2C_READ_CONTINUOUSLY. I2C_END_TX_MASK
                          may be OR&#39;ed when required

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        &#34;&#34;&#34;
        if address not in self.i2c_map:
            self.i2c_map[address] = {&#39;value&#39;: None, &#39;callback&#39;: callback}
        if register is not None:
            data = [address, read_type, register &amp; 0x7f, (register &gt;&gt; 7) &amp; 0x7f,
                    number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
        else:
            data = [address, read_type,
                    number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    async def i2c_write(self, address, args):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list

        &#34;&#34;&#34;
        data = [address, PrivateConstants.I2C_WRITE]
        for item in args:
            item_lsb = item &amp; 0x7f
            data.append(item_lsb)
            item_msb = (item &gt;&gt; 7) &amp; 0x7f
            data.append(item_msb)
        await self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    async def keep_alive(self, period=1, margin=.3):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Periodically send a keep alive message to the Arduino.

        If the Arduino does not received a keep alive, the Arduino
        will physically reset itself.

        Frequency of keep alive transmission is calculated as follows:
        keep_alive_sent = period - (period * margin)


        :param period: Time period between keepalives. Range is 0-10 seconds.
                       0 disables the keepalive mechanism.

        :param margin: Safety margin to assure keepalives are sent before
                    period expires. Range is 0.1 to 0.9
        &#34;&#34;&#34;

        self.period = period
        self.margin = margin
        if period &lt; 0:
            period = 0

        # if there is a currently running keep alive task
        # and the the period is 0, kill the task and return
        if period == 0 and self.keep_alive_task:
            self.keep_alive_task.cancel()
            return

        self.keep_alive_interval = period &amp; 0x7f, (period &gt;&gt; 7) &amp; 0x7f
        # if there is no keep alive task, start one
        if not self.keep_alive_task:
            self.keep_alive_task = self.loop.create_task(
                self._send_keep_alive())

    async def play_tone(self, pin_number, frequency, duration):
        &#34;&#34;&#34;

        This is FirmataExpress feature

        Play a tone at the specified frequency for the specified duration.

        :param pin_number: arduino pin number

        :param frequency: tone frequency in hz

        :param duration: duration in milliseconds

        &#34;&#34;&#34;
        await self._play_tone(pin_number, PrivateConstants.TONE_TONE, frequency=frequency,
                              duration=duration)

    async def play_tone_continuously(self, pin_number, frequency):
        &#34;&#34;&#34;

        This is a FirmataExpress feature

        This method plays a tone continuously until play_tone_off is called.

        :param pin_number: arduino pin number

        :param frequency: tone frequency in hz

        &#34;&#34;&#34;

        await self._play_tone(pin_number, PrivateConstants.TONE_TONE, frequency=frequency,
                              duration=None)

    async def play_tone_off(self, pin_number):
        &#34;&#34;&#34;
        This is a FirmataExpress Feature

        This method turns tone off for the specified pin.

        :param pin_number: arduino pin number

        &#34;&#34;&#34;

        await self._play_tone(pin_number, PrivateConstants.TONE_NO_TONE,
                              frequency=None, duration=None)

    async def _play_tone(self, pin, tone_command, frequency, duration):
        &#34;&#34;&#34;
        This method will call the Tone library for the selected pin.
        It requires FirmataPlus to be loaded onto the arduino

        If the tone command is set to TONE_TONE, then the specified
        tone will be played.

        Else, if the tone command is TONE_NO_TONE, then any currently
        playing tone will be disabled.

        :param pin: arduino pin number

        :param tone_command: Either TONE_TONE, or TONE_NO_TONE

        :param frequency: Frequency of tone

        :param duration: Duration of tone in milliseconds

        &#34;&#34;&#34;
        # convert the integer values to bytes
        if tone_command == PrivateConstants.TONE_TONE:
            # duration is specified
            if duration:
                data = [tone_command, pin, frequency &amp; 0x7f,
                        (frequency &gt;&gt; 7) &amp; 0x7f,
                        duration &amp; 0x7f, (duration &gt;&gt; 7) &amp; 0x7f]

            else:
                data = [tone_command, pin,
                        frequency &amp; 0x7f, (frequency &gt;&gt; 7) &amp; 0x7f, 0, 0]
        # turn off tone
        else:
            data = [tone_command, pin]
        await self._send_sysex(PrivateConstants.TONE_DATA, data)

    async def pwm_write(self, pin, value):
        &#34;&#34;&#34;
        This is an alias for PWM_write
        Set the selected pin to the specified value.

        :param pin: PWM pin number

        :param value: Pin value (0 - 0x4000)

        &#34;&#34;&#34;
        if PrivateConstants.ANALOG_MESSAGE + pin &lt; 0xf0:
            command = [PrivateConstants.ANALOG_MESSAGE + pin, value &amp; 0x7f,
                       (value &gt;&gt; 7) &amp; 0x7f]
            await self._send_command(command)
        else:
            await self._analog_write_extended(pin, value)

    async def send_reset(self):
        &#34;&#34;&#34;
        Send a Sysex reset command to the arduino

        &#34;&#34;&#34;
        try:
            await self._send_command([PrivateConstants.SYSTEM_RESET])
        except RuntimeError:
            raise

    async def set_pin_mode_analog_input(self, pin_number, callback=None,
                                        differential=1):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param pin_number: arduino pin number

        :param callback: async callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.

        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 2

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.ANALOG,
                                 callback=callback,
                                 differential=differential)

    async def set_pin_mode_dht(self, pin_number, sensor_type=22, differential=.1,
                               callback=None):
        &#34;&#34;&#34;
        Configure a DHT sensor prior to operation.
        Up to 6 DHT sensors are supported

        :param pin_number: digital pin number on arduino.

        :param sensor_type: type of dht sensor
                            Valid values = DHT11, DHT22,

        :param differential: This value needs to be met for a callback
                             to be invoked.

        :param callback: callback function

        callback: returns a data list:

        [pin_type, pin_number, DHT type, validation flag, humidity value, temperature
        raw_time_stamp]

        The pin_type for DHT input pins = 15

        Validation Flag Values:

            No Errors = 0

            Checksum Error = 1

            Timeout Error = 2

            Invalid Value = 999
        &#34;&#34;&#34;

        # if the pin is not currently associated with a DHT device
        # initialize it.
        if pin_number not in self.dht_list:
            self.dht_list.append(pin_number)
            self.digital_pins[pin_number].cb = callback
            self.digital_pins[pin_number].current_value = [0, 0]
            self.digital_pins[pin_number].differential = differential
            data = [pin_number, sensor_type]
            await self._send_sysex(PrivateConstants.DHT_CONFIG, data)
        else:
            # allow user to change the differential value
            self.digital_pins[pin_number].differential = differential

    async def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: arduino pin number

        :param callback: async callback function

        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 0

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.INPUT, callback)

    async def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: arduino pin number

        :param callback: async callback function

        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 11

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.PULLUP, callback)

    async def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: arduino pin number
        &#34;&#34;&#34;

        await self._set_pin_mode(pin_number, PrivateConstants.OUTPUT)

    # noinspection PyIncorrectDocstring
    async def set_pin_mode_i2c(self, read_delay_time=0):
        &#34;&#34;&#34;
        Establish the standard Arduino i2c pins for i2c utilization.

        NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
        This method initializes Firmata for I2c operations.

        :param read_delay_time (in microseconds): an optional parameter,
                                                  default is 0

        &#34;&#34;&#34;
        data = [read_delay_time &amp; 0x7f, (read_delay_time &gt;&gt; 7) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.I2C_CONFIG, data)

    async def set_pin_mode_pwm(self, pin_number):
        &#34;&#34;&#34;

        This is an alias for set_pin_mode_pwm_output.

        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        await self.set_pin_mode_pwm_output(pin_number)

    async def set_pin_mode_pwm_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.PWM)

    async def set_pin_mode_servo(self, pin, min_pulse=544, max_pulse=2400):
        &#34;&#34;&#34;
        Configure a pin as a servo pin. Set pulse min, max in ms.

        :param pin: Servo Pin.

        :param min_pulse: Min pulse width in ms.

        :param max_pulse: Max pulse width in ms.

        &#34;&#34;&#34;
        command = [pin, min_pulse &amp; 0x7f, (min_pulse &gt;&gt; 7) &amp; 0x7f,
                   max_pulse &amp; 0x7f,
                   (max_pulse &gt;&gt; 7) &amp; 0x7f]

        await self._send_sysex(PrivateConstants.SERVO_CONFIG, command)

    async def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                                 callback=None, timeout=80000):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Configure the pins,ping interval and maximum distance for an HC-SR04
        type device.

        Up to a maximum of 6 SONAR devices is supported.
        If the maximum is exceeded a message is sent to the console and the
        request is ignored.

        NOTE: data is measured in centimeters

        :param trigger_pin: The pin number of for the trigger (transmitter).

        :param echo_pin: The pin number for the received echo.

        :param callback: optional callback function to report sonar data changes

        :param timeout: a tuning parameter. 80000UL equals 80ms.

        callback returns a data list:

        [pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]

        The pin_type for sonar pins = 12


        &#34;&#34;&#34;
        # if there is an entry for the trigger pin in existence,
        # ignore the duplicate request.
        if trigger_pin in self.active_sonar_map:
            return

        timeout_lsb = timeout &amp; 0x7f
        timeout_msb = (timeout &gt;&gt; 7) &amp; 0x7f
        data = [trigger_pin, echo_pin, timeout_lsb,
                timeout_msb]

        await self._set_pin_mode(trigger_pin, PrivateConstants.SONAR,
                                 PrivateConstants.INPUT)
        await self._set_pin_mode(echo_pin, PrivateConstants.SONAR,
                                 PrivateConstants.INPUT)
        # update the ping data map for this pin
        if len(self.active_sonar_map) &gt; 6:
            print(&#39;sonar_config: maximum number of devices assigned&#39;
                  &#39; - ignoring request&#39;)
        else:
            self.active_sonar_map[trigger_pin] = [callback, 0, 0]

        await self._send_sysex(PrivateConstants.SONAR_CONFIG, data)

    async def set_pin_mode_stepper(self, steps_per_revolution, stepper_pins):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Configure stepper motor prior to operation.
        This is a FirmataPlus feature.

        NOTE: Single stepper only. Multiple steppers not supported.

        :param steps_per_revolution: number of steps per motor revolution

        :param stepper_pins: a list of control pin numbers - either 4 or 2

        &#34;&#34;&#34;
        data = [PrivateConstants.STEPPER_CONFIGURE,
                steps_per_revolution &amp; 0x7f,
                (steps_per_revolution &gt;&gt; 7) &amp; 0x7f]
        for pin in range(len(stepper_pins)):
            data.append(stepper_pins[pin])
        await self._send_sysex(PrivateConstants.STEPPER_DATA, data)

    async def set_pin_mode_tone(self, pin_number):
        &#34;&#34;&#34;
        This is FirmataExpress feature.

        Set a PWM pin to tone mode.

        :param pin_number: arduino pin number

        &#34;&#34;&#34;
        command = [PrivateConstants.SET_PIN_MODE, pin_number,
                   PrivateConstants.TONE]
        await self._send_command(command)

    async def _set_pin_mode(self, pin_number, pin_state, callback=None,
                            differential=1):
        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: arduino pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP - for SERVO use
                          servo_config()
                          For DHT   use: set_pin_mode_dht

        :param callback: A reference to an async call back function to be
                         called when pin data value changes

        :param differential: This value needs to be met for a callback
                             to be invoked

        &#34;&#34;&#34;

        # There is a potential start up race condition when running pymata3.
        # This is a workaround for that race condition
        #
        if not len(self.digital_pins):
            await asyncio.sleep(2)
        if callback:
            if pin_state == PrivateConstants.INPUT:
                self.digital_pins[pin_number].cb = callback
            elif pin_state == PrivateConstants.PULLUP:
                self.digital_pins[pin_number].cb = callback
                self.digital_pins[pin_number].pull_up = True
            elif pin_state == PrivateConstants.ANALOG:
                self.analog_pins[pin_number].cb = callback
                self.analog_pins[pin_number].differential = differential
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        pin_mode = pin_state

        if pin_mode == PrivateConstants.ANALOG:
            pin_number = pin_number + self.first_analog_pin

        command = [PrivateConstants.SET_PIN_MODE, pin_number, pin_mode]
        await self._send_command(command)

        if pin_state == PrivateConstants.INPUT or pin_state == PrivateConstants.PULLUP:
            await self.enable_digital_reporting(pin_number)
        else:
            pass

        await asyncio.sleep(.05)

    async def _send_keep_alive(self):
        &#34;&#34;&#34;
        This is a the task to continuously send keep alive messages
        &#34;&#34;&#34;
        while not self.shutdown_flag:
            if self.period:
                await self._send_sysex(PrivateConstants.KEEP_ALIVE,
                                       self.keep_alive_interval)

                # wait the requested amount of time before sending the next
                # keep alive to the Arduino
                await asyncio.sleep(self.period - self.margin)

    async def set_sampling_interval(self, interval):
        &#34;&#34;&#34;
        This method sends the desired sampling interval to Firmata.

        Note: Standard Firmata  will ignore any interval less than
              10 milliseconds

        :param interval: Integer value for desired sampling interval
                         in milliseconds

        &#34;&#34;&#34;
        data = [interval &amp; 0x7f, (interval &gt;&gt; 7) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.SAMPLING_INTERVAL, data)

    async def servo_write(self, pin, position):
        &#34;&#34;&#34;
        This is an alias for pwm_write to set
        the position of a servo that has been
        previously configured using set_pin_mode_servo.

        :param pin: arduino pin number

        :param position: servo position

        &#34;&#34;&#34;

        await self.pwm_write(pin, position)

    async def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.

        &#34;&#34;&#34;

        self.shutdown_flag = True

        # stop all reporting - both analog and digital
        for pin in range(len(self.analog_pins)):
            await self.disable_analog_reporting(pin)

        for pin in range(len(self.digital_pins)):
            await self.disable_digital_reporting(pin)

        try:
            if self.close_loop_on_shutdown:
                self.loop.stop()
            await self.send_reset()
            await self.serial_port.reset_input_buffer()
            await self.serial_port.close()
            if self.close_loop_on_shutdown:
                self.loop.close()
        except (RuntimeError, SerialException):
            pass

    async def sonar_read(self, trigger_pin):
        &#34;&#34;&#34;
        This is a FirmataExpress feature

        Retrieve Ping (HC-SR04 type) data. The data is presented as a
        dictionary.

        The &#39;key&#39; is the trigger pin specified in sonar_config()
        and the &#39;data&#39; is the current measured distance (in centimeters)
        for that pin. If there is no data, the value is set to None.

        :param trigger_pin: key into sonar data map

        :returns: [last distance, raw time stamp]
        &#34;&#34;&#34;

        sonar_pin_entry = self.active_sonar_map.get(trigger_pin)
        return [sonar_pin_entry[1], sonar_pin_entry[2]]
        # value = sonar_pin_entry[1]
        # return value

    async def stepper_write(self, motor_speed, number_of_steps):
        &#34;&#34;&#34;
        This is a FirmataExpress feature

        Move a stepper motor for the number of steps at the specified speed.
        This is a FirmataPlus feature.

        :param motor_speed: 21 bits of data to set motor speed

        :param number_of_steps: 14 bits for number of steps &amp; direction
                                positive is forward, negative is reverse

        &#34;&#34;&#34;
        if number_of_steps &gt; 0:
            direction = 1
        else:
            direction = 0
        abs_number_of_steps = abs(number_of_steps)
        data = [PrivateConstants.STEPPER_STEP, motor_speed &amp; 0x7f,
                (motor_speed &gt;&gt; 7) &amp; 0x7f, (motor_speed &gt;&gt; 14) &amp; 0x7f,
                abs_number_of_steps &amp; 0x7f, (abs_number_of_steps &gt;&gt; 7) &amp; 0x7f,
                direction]
        await self._send_sysex(PrivateConstants.STEPPER_DATA, data)

    async def _arduino_report_dispatcher(self):
        &#34;&#34;&#34;
        This is a private method.
        It continually accepts and interprets data coming from Firmata,and then
        dispatches the correct handler to process the data.

        :returns: This method never returns
        &#34;&#34;&#34;
        # sysex commands are assembled into this list for processing
        sysex = []

        while True:
            if self.shutdown_flag:
                break
            try:
                if not self.ip_address:
                    next_command_byte = await self.serial_port.read()
                else:
                    next_command_byte = await self.socket_transport.read()

            except TypeError:
                continue
            # if this is a SYSEX command, then assemble the entire
            # command process it
            if next_command_byte == PrivateConstants.START_SYSEX:
                while next_command_byte != PrivateConstants.END_SYSEX:
                    if not self.ip_address:
                        next_command_byte = await self.serial_port.read()
                    else:
                        next_command_byte = await self.socket_transport.read()
                    sysex.append(next_command_byte)
                await self.command_dictionary[sysex[0]](sysex)
                sysex = []
            # if this is an analog message, process it.
            elif 0xE0 &lt;= next_command_byte &lt;= 0xEF:
                # analog message
                # assemble the entire analog message in command
                command = []
                # get the pin number for the message
                pin = next_command_byte &amp; 0x0f
                command.append(pin)
                # get the next 2 bytes for the command
                command = await self._wait_for_data(command, 2)
                # process the analog message
                await self._analog_message(command)
            # handle the digital message
            elif 0x90 &lt;= next_command_byte &lt;= 0x9F:
                command = []
                port = next_command_byte &amp; 0x0f
                command.append(port)
                command = await self._wait_for_data(command, 2)
                await self._digital_message(command)
            # handle all other messages by looking them up in the
            # command dictionary
            elif next_command_byte in self.command_dictionary:
                await self.command_dictionary[next_command_byte]()
                await asyncio.sleep(self.sleep_tune)
            else:
                continue

    &#39;&#39;&#39;
    Firmata message handlers
    &#39;&#39;&#39;

    async def _analog_mapping_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for the analog mapping response message.

        :param data: response data

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.ANALOG_MAPPING_RESPONSE] = \
            data[1:-1]

    async def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[PrivateConstants.MSB] &lt;&lt; 7) + data[PrivateConstants.LSB]

        # only report when there is a change in value
        differential = abs(value - self.analog_pins[pin].current_value)
        if differential &gt;= self.analog_pins[pin].differential:
            self.analog_pins[pin].current_value = value
            time_stamp = time.time()
            self.analog_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            message = [PrivateConstants.ANALOG, pin, value, time_stamp]

            if self.analog_pins[pin].cb:
                # if self.analog_pins[pin].cb_type:
                await self.analog_pins[pin].cb(message)

    async def _capability_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for capability report responses.

        :param data: capability report

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.CAPABILITY_RESPONSE] = data[1:-1]

    async def _dht_read_response(self, data):
        &#34;&#34;&#34;
        Process the dht response message.

        Values are calculated using:
                humidity = (_bits[0] * 256 + _bits[1]) * 0.1

                temperature = ((_bits[2] &amp; 0x7F) * 256 + _bits[3]) * 0.1

        error codes:
        0 - OK
        1 - DHTLIB_ERROR_TIMEOUT
        2 - Checksum error

        :param: data: [Report Type, pin, dht_type, validation_flag, humidity, temperature]
        &#34;&#34;&#34;

        # get the time of the report
        time_stamp = time.time()

        # adjust data to just show values from sensor
        data = data[1:-1]
        # initiate a list for a potential call back
        reply_data = [PrivateConstants.DHT]

        # get the pin and type of the dht
        pin = data[0]
        reply_data.append(pin)
        dht_type = data[1]
        reply_data.append(dht_type)
        humidity = temperature = 0

        if data[2] == 0:  # all is well
            humidity = float(data[3] + data[4] / 10)
            temperature = float(data[5] + data[6] / 10)

        self.digital_pins[pin].event_time = time_stamp
        reply_data.append(data[2])
        reply_data.append(humidity)
        reply_data.append(temperature)
        reply_data.append(time_stamp)

        # retrieve the last reported values
        last_value = self.digital_pins[pin].current_value

        self.digital_pins[pin].current_value = [humidity, temperature]
        if self.digital_pins[pin].cb:
            # only report changes
            # has the humidity changed?
            if last_value[0] != humidity:

                differential = abs(humidity - last_value[0])
                if differential &gt;= self.digital_pins[pin].differential:
                    await self.digital_pins[pin].cb(reply_data)
                return
            if last_value[1] != temperature:
                differential = abs(temperature - last_value[1])
                if differential &gt;= self.digital_pins[pin].differential:
                    await self.digital_pins[pin].cb(reply_data)
                return

    async def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        port = data[0]
        # noinspection PyPep8,PyPep8
        port_data = (data[PrivateConstants.MSB] &lt;&lt; 7) + \
                    data[PrivateConstants.LSB]
        pin = port * 8
        for pin in range(pin, min(pin + 8, len(self.digital_pins))):
            # get pin value
            value = port_data &amp; 0x01

            last_value = self.digital_pins[pin].current_value

            # set the current value in the pin structure
            self.digital_pins[pin].current_value = value
            time_stamp = time.time()
            self.digital_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            # if self.legacy_mode:
            #     message = [pin, value, PrivateConstants.INPUT, time_stamp]
            # else:
            if self.digital_pins[pin].pull_up:
                message = [PrivateConstants.PULLUP, pin, value, time_stamp]
            else:
                message = [PrivateConstants.INPUT, pin, value, time_stamp]

            if last_value != value:
                if self.digital_pins[pin].cb:
                    await self.digital_pins[pin].cb(message)

            port_data &gt;&gt;= 1

    async def _i2c_reply(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles replies to i2c_read requests. It stores the data
        for each i2c device address in a dictionary called i2c_map.
        The data may be retrieved via a polling call to i2c_get_read_data().
        It a callback was specified in pymata.i2c_read, the raw data is sent
        through the callback

        :param data: raw data returned from i2c device

        &#34;&#34;&#34;
        # remove the start and end sysex commands from the data
        data = data[1:-1]
        reply_data = [PrivateConstants.I2C]
        # reassemble the data from the firmata 2 byte format
        address = (data[0] &amp; 0x7f) + (data[1] &lt;&lt; 7)

        # if we have an entry in the i2c_map, proceed
        if address in self.i2c_map:
            # get 2 bytes, combine them and append to reply data list
            for i in range(0, len(data), 2):
                combined_data = (data[i] &amp; 0x7f) + (data[i + 1] &lt;&lt; 7)
                reply_data.append(combined_data)

            current_time = time.time()
            reply_data.append(current_time)

            # place the data in the i2c map without storing the address byte or
            #  register byte (returned data only)
            map_entry = self.i2c_map.get(address)
            map_entry[&#39;value&#39;] = reply_data[2:]
            map_entry[&#39;time_stamp&#39;] = current_time
            self.i2c_map[address] = map_entry
            cb = map_entry.get(&#39;callback&#39;)
            if cb:
                # send everything, including address and register bytes back
                # to caller
                await cb(reply_data)

    async def _pin_state_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles pin state query response messages.

        :param data: Pin state message

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = data[1:-1]

    async def _report_firmware(self, sysex_data):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method handles the sysex &#39;report firmware&#39; command sent by
        Firmata (0x79).

        It assembles the firmware version by concatenating the major and
        minor version number components and the firmware identifier into
        a string.

        e.g. &#34;2.3 StandardFirmata.ino&#34;

        :param sysex_data: Sysex data sent from Firmata

        &#34;&#34;&#34;
        # first byte after command is major number
        major = sysex_data[1]
        version_string = str(major)

        # next byte is minor number
        minor = sysex_data[2]

        # append a dot to major number
        version_string += &#39;.&#39;

        # append minor number
        version_string += str(minor)
        # add a space after the major and minor numbers
        version_string += &#39; &#39;

        # slice the identifier - from the first byte after the minor
        #  number up until, but not including the END_SYSEX byte

        name = sysex_data[3:-1]
        firmware_name_iterator = iter(name)

        # convert each element from two 7-bit bytes into characters, then add each
        # character to the version string
        for e in firmware_name_iterator:
            version_string += chr(e + (next(firmware_name_iterator) &lt;&lt; 7))

        # store the value
        self.query_reply_data[PrivateConstants.REPORT_FIRMWARE] = version_string

    async def _report_version(self):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method reads the following 2 bytes after the report version
        command (0xF9 - non sysex).

        The first byte is the major number and the second byte is the
        minor number.

        &#34;&#34;&#34;
        # get next two bytes
        if not self.ip_address:
            major = await self.serial_port.read()
        else:
            major = await self.socket_transport.read()
        version_string = str(major)

        if not self.ip_address:
            minor = await self.serial_port.read()
        else:
            minor = await self.socket_transport.read()

        version_string += &#39;.&#39;
        version_string += str(minor)
        self.query_reply_data[PrivateConstants.REPORT_VERSION] = version_string

    async def _sonar_data(self, data):
        &#34;&#34;&#34;
        This method handles the incoming sonar data message and stores
        the data in the response table.

        :param data: Message data from Firmata

        &#34;&#34;&#34;

        # strip off sysex start and end
        data = data[1:-1]
        pin_number = data[0]
        val = int((data[PrivateConstants.MSB] &lt;&lt; 7) +
                  data[PrivateConstants.LSB])
        reply_data = [PrivateConstants.SONAR]

        sonar_pin_entry = self.active_sonar_map[pin_number]

        if sonar_pin_entry[0] is not None:
            # check if value changed since last reading
            if sonar_pin_entry[1] != val:
                sonar_pin_entry[1] = val
                time_stamp = time.time()
                sonar_pin_entry[2] = time_stamp
                self.active_sonar_map[pin_number] = sonar_pin_entry
                # Do a callback if one is specified in the table
                if sonar_pin_entry[0]:
                    reply_data.append(pin_number)
                    reply_data.append(val)
                    reply_data.append(time_stamp)

                    if sonar_pin_entry[1]:
                        await sonar_pin_entry[0](reply_data)

        # update the data in the table with latest value
        else:
            sonar_pin_entry[1] = val
            self.active_sonar_map[pin_number] = sonar_pin_entry

        await asyncio.sleep(self.sleep_tune)

    async def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.
        The method sends a non-sysex command to Firmata.

        :param command:  command data

        :returns: number of bytes sent
        &#34;&#34;&#34;
        send_message = &#34;&#34;

        for i in command:
            send_message += chr(i)
        result = None
        if not self.ip_address:
            for data in send_message:
                try:
                    result = await self.serial_port.write(data)
                except AttributeError:
                    raise RuntimeError
        else:
            for data in send_message:
                try:
                    result = await self.socket_transport.write(data)
                except AttributeError:
                    raise RuntimeError

        return result

    async def _send_sysex(self, sysex_command, sysex_data=None):
        &#34;&#34;&#34;
        This is a private utility method.
        This method sends a sysex command to Firmata.

        :param sysex_command: sysex command

        :param sysex_data: data for command

        &#34;&#34;&#34;
        if not sysex_data:
            sysex_data = []

        # convert the message command and data to characters
        sysex_message = chr(PrivateConstants.START_SYSEX)
        sysex_message += chr(sysex_command)
        if len(sysex_data):
            for d in sysex_data:
                sysex_message += chr(d)
        sysex_message += chr(PrivateConstants.END_SYSEX)

        if not self.ip_address:
            for data in sysex_message:
                await self.serial_port.write(data)
        else:
            await self.socket_transport.write(sysex_message)
            await asyncio.sleep(.01)

        # noinspection PyMethodMayBeStatic

    # noinspection PyMethodMayBeStatic
    async def _string_data(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is the message handler for String data messages that will be
        printed to the console.

        :param data:  message

        &#34;&#34;&#34;
        reply = &#39;&#39;
        data = data[1:-1]
        for x in data:
            reply_data = x
            if reply_data:
                reply += chr(reply_data)
        print(reply)

    async def _wait_for_data(self, current_command, number_of_bytes):
        &#34;&#34;&#34;
        This is a private utility method.
        This method accumulates the requested number of bytes and
        then returns the full command

        :param current_command:  command id

        :param number_of_bytes:  how many bytes to wait for

        :returns: command
        &#34;&#34;&#34;
        while number_of_bytes:
            if not self.ip_address:
                next_command_byte = await self.serial_port.read()
                current_command.append(next_command_byte)
                number_of_bytes -= 1
            else:
                next_command_byte = await self.socket_transport.read()
                current_command.append(next_command_byte)
                number_of_bytes -= 1
        return current_command</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pymata_express.pymata_express.PymataExpress"><code class="flex name class">
<span>class <span class="ident">PymataExpress</span></span>
<span>(</span><span>com_port=None, baud_rate=115200, arduino_instance_id=1, arduino_wait=4, sleep_tune=0.0001, autostart=True, loop=None, shutdown_on_exception=True, close_loop_on_shutdown=True, ip_address=None, ip_port=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class exposes and implements the PymataExpress API.
It includes the public API methods as well as
a set of private methods. This is an asyncio API</p>
<p>If you are using the Firmata Express Arduino sketch,
and have a single Arduino connected to your computer,
then you may accept all the default values.</p>
<p>If you are using some other Firmata sketch, then
you must specify both the com_port and baudrate for
as serial connection, or ip_address and ip_port if
using StandardFirmataWifi.</p>
<p>:param com_port: e.g. COM3 or /dev/ttyACM0.</p>
<p>:param baud_rate: Match this to the Firmata sketch in use.</p>
<p>:param arduino_instance_id: If you are using the Firmata
Express sketch, match this
value to that in the sketch.</p>
<p>:param arduino_wait: Amount of time to wait for an Arduino to
fully reset itself.</p>
<p>:param sleep_tune: A tuning parameter (typically not changed by user)</p>
<p>:param autostart: If you wish to call the start method within
your application, then set this to False.</p>
<p>:param loop: optional user provided event loop</p>
<p>:param shutdown_on_exception: call shutdown before raising
a RunTimeError exception, or
receiving a KeyboardInterrupt exception</p>
<p>:param close_loop_on_shutdown: stop and close the event loop loop
when a shutdown is called or a serial
error occurs</p>
<p>:param ip_address: When interfacing with StandardFirmataWifi, set the
IP address of the device.</p>
<p>:param ip_port: When interfacing with StandardFirmataWifi, set the
ip port of the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PymataExpress:
    &#34;&#34;&#34;
    This class exposes and implements the PymataExpress API.
    It includes the public API methods as well as
    a set of private methods. This is an asyncio API

    &#34;&#34;&#34;

    # noinspection PyPep8,PyPep8
    def __init__(self, com_port=None, baud_rate=115200,
                 arduino_instance_id=1, arduino_wait=4,
                 sleep_tune=0.0001, autostart=True,
                 loop=None, shutdown_on_exception=True,
                 close_loop_on_shutdown=True,
                 ip_address=None, ip_port=None,
                 ):
        &#34;&#34;&#34;
        If you are using the Firmata Express Arduino sketch,
        and have a single Arduino connected to your computer,
        then you may accept all the default values.

        If you are using some other Firmata sketch, then
        you must specify both the com_port and baudrate for
        as serial connection, or ip_address and ip_port if
        using StandardFirmataWifi.

        :param com_port: e.g. COM3 or /dev/ttyACM0.

        :param baud_rate: Match this to the Firmata sketch in use.

        :param arduino_instance_id: If you are using the Firmata
                                    Express sketch, match this
                                    value to that in the sketch.

        :param arduino_wait: Amount of time to wait for an Arduino to
                             fully reset itself.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param autostart: If you wish to call the start method within
                          your application, then set this to False.

        :param loop: optional user provided event loop

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :param close_loop_on_shutdown: stop and close the event loop loop
                                       when a shutdown is called or a serial
                                       error occurs

        :param ip_address: When interfacing with StandardFirmataWifi, set the
                           IP address of the device.

        :param ip_port: When interfacing with StandardFirmataWifi, set the
                        ip port of the device.
        &#34;&#34;&#34;
        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if sys.platform == &#39;win32&#39;:
            if python_version[0] &gt; 3:
                if python_version[1] &gt;= 8:
                    if python_version[2] &gt;= 3:
                        pass
                    else:
                        raise RuntimeError(&#34;ERROR: Python 3.8.2 or greater is &#34;
                                           &#34;required for use of this program on Windows.&#34;)

        elif python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters
        self.com_port = com_port
        self.baud_rate = baud_rate
        self.arduino_instance_id = arduino_instance_id
        self.arduino_wait = arduino_wait
        self.sleep_tune = sleep_tune
        self.autostart = autostart
        self.ip_address = ip_address
        self.ip_port = ip_port

        # set the event loop
        if loop is None:
            self.loop = asyncio.get_event_loop()
        else:
            self.loop = loop

        self.shutdown_on_exception = shutdown_on_exception
        self.close_loop_on_shutdown = close_loop_on_shutdown

        # a list of PinData objects - one for each pin segregated by pin type
        # see pin_data.py
        self.analog_pins = []
        self.digital_pins = []

        # serial port in use
        self.serial_port = None

        # reference to tcp/ip socket
        self.sock = None

        # An i2c_map entry consists of a device i2c address as the key, and
        #  the value of the key consists of a dictionary containing 2 entries.
        #  The first entry. &#39;value&#39; contains the last value reported, and
        # the second, &#39;callback&#39; contains a reference to a callback function,
        # and the third, a time-stamp
        # For example:
        # {12345: {&#39;value&#39;: 23, &#39;callback&#39;: None, time_stamp:None}}
        self.i2c_map = {}

        # The active_sonar_map maps the sonar trigger pin number (the key)
        # to the current data value returned
        # if a callback was specified, it is stored in the map as well.
        # A map entry consists of:
        #   pin: [callback, current_data_returned, time_stamp]
        self.active_sonar_map = {}

        # keep alive variables
        self.keep_alive_interval = []
        self.period = 0
        self.margin = 0
        self.keep_alive_task = None

        # first analog pin number
        self.first_analog_pin = None

        # dht error flag
        self.dht_sensor_error = False

        # a list of pins assigned to DHT devices
        self.dht_list = []

        # generic asyncio task holder
        self.the_task = None
        self.the_socket_receive_task = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        # reference to instant of pymata_express_socket
        self.socket_transport = None

        self.using_firmata_express = False

        # this dictionary for mapping incoming Firmata message types to
        # handlers for the messages
        self.command_dictionary = {PrivateConstants.REPORT_VERSION:
                                       self._report_version,
                                   PrivateConstants.REPORT_FIRMWARE:
                                       self._report_firmware,
                                   PrivateConstants.CAPABILITY_RESPONSE:
                                       self._capability_response,
                                   PrivateConstants.ANALOG_MAPPING_RESPONSE:
                                       self._analog_mapping_response,
                                   PrivateConstants.PIN_STATE_RESPONSE:
                                       self._pin_state_response,
                                   PrivateConstants.STRING_DATA:
                                       self._string_data,
                                   PrivateConstants.ANALOG_MESSAGE:
                                       self._analog_message,
                                   PrivateConstants.DIGITAL_MESSAGE:
                                       self._digital_message,
                                   PrivateConstants.I2C_REPLY:
                                       self._i2c_reply,
                                   PrivateConstants.SONAR_DATA:
                                       self._sonar_data,
                                   PrivateConstants.DHT_DATA:
                                       self._dht_read_response,
                                   }

        # report query results are stored in this dictionary
        self.query_reply_data = {PrivateConstants.REPORT_VERSION: &#39;&#39;,
                                 PrivateConstants.STRING_DATA: &#39;&#39;,
                                 PrivateConstants.REPORT_FIRMWARE: &#39;&#39;,
                                 PrivateConstants.CAPABILITY_RESPONSE: None,
                                 PrivateConstants.ANALOG_MAPPING_RESPONSE:
                                     None,
                                 PrivateConstants.PIN_STATE_RESPONSE: None,
                                 PrivateConstants.DHT_DATA: &#39;&#39;,
                                 }

        print(&#39;{}{}{}&#39;.format(&#39;\n&#39;, &#39;Pymata Express Version &#39; +
                              PrivateConstants.PYMATA_EXPRESS_VERSION,
                              &#39;\nCopyright (c) 2018-2020 Alan Yorinks All &#39;
                              &#39;rights reserved.\n&#39;))

        if autostart:
            self.loop.run_until_complete(self.start_aio())

    async def start_aio(self):
        &#34;&#34;&#34;
        This method may be called directly, if the autostart
        parameter in __init__ is set to false.

        This method instantiates the serial interface and then performs auto pin
        discovery if using a serial interface, or creates and connects to
        a TCP/IP enabled device running StandardFirmataWiFi.

        Use this method if you wish to start PymataExpress manually from
        an asyncio function.
         &#34;&#34;&#34;

        # using the serial port
        if not self.ip_address:
            if not self.com_port:
                # user did not specify a com_port
                try:
                    await self._find_arduino()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        await self.shutdown()
            else:
                # com_port specified - set com_port and baud rate
                try:
                    await self._manual_open()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        await self.shutdown()

            if self.com_port:
                print(&#39;{}{}\n&#39;.format(&#39;\nArduino found and connected to &#39;,
                                      self.com_port))

            # no com_port found - raise a runtime exception
            else:
                if self.shutdown_on_exception:
                    await self.shutdown()
                raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)
        # connect to a wifi enabled device server
        else:
            self.socket_transport = PymataExpressSocket(self.ip_address, self.ip_port,
                                                        self.loop)
            await self.socket_transport.start()
            # self.loop.create_task(self.socket_transport.read())

        # start the command dispatcher loop
        if not self.loop:
            self.loop = asyncio.get_event_loop()
        self.the_task = self.loop.create_task(self._arduino_report_dispatcher())

        # get arduino firmware version and print it
        firmware_version = await self.get_firmware_version()
        if not firmware_version:
            print(&#39;*** Firmware Version retrieval timed out. ***&#39;)
            print(&#39;\nDo you have Arduino connectivity and do you have a &#39;)
            print(&#39;Firmata sketch uploaded to the board and are connected&#39;)
            print(&#39;to the correct serial port.\n&#39;)
            print(&#39;To see a list of serial ports, type: &#39;
                  &#39;&#34;list_serial_ports&#34; in your console.&#39;)
            if self.shutdown_on_exception:
                await self.shutdown()
            raise RuntimeError
        else:
            if self.using_firmata_express:
                version_number = firmware_version[0:3]
                if version_number != PrivateConstants.FIRMATA_EXPRESS_VERSION:
                    raise RuntimeError(f&#39;You must use FirmataExpress version 1.2. &#39;
                                       f&#39;Version Found = {version_number}&#39;)
            print(&#34;\nArduino Firmware ID: &#34; + firmware_version)

        # try to get an analog pin map. if it comes back as none - shutdown
        report = await self.get_analog_map()
        if not report:
            print(&#39;*** Analog map retrieval timed out. ***&#39;)
            print(&#39;\nDo you have Arduino connectivity and do you have a &#39;
                  &#39;Firmata sketch uploaded to the board?&#39;)
            if self.shutdown_on_exception:
                await self.shutdown()
            raise RuntimeError

        # custom assemble the pin lists
        for pin in report:
            digital_data = PinData()
            self.digital_pins.append(digital_data)
            if pin != PrivateConstants.IGNORE:
                analog_data = PinData()
                self.analog_pins.append(analog_data)

        print(&#39;{} {} {} {} {}&#39;.format(&#39;Auto-discovery complete. Found&#39;,
                                      len(self.digital_pins),
                                      &#39;Digital Pins and&#39;,
                                      len(self.analog_pins),
                                      &#39;Analog Pins\n\n&#39;))
        self.first_analog_pin = len(self.digital_pins) - len(self.analog_pins)
        await self.set_sampling_interval(19)

    async def get_event_loop(self):
        &#34;&#34;&#34;
        Return the currently active asyncio event loop

        :return: Active event loop

        &#34;&#34;&#34;
        return self.loop

    async def _find_arduino(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for an Arduino
        containing a sketch that has a matching arduino_instance_id as
        specified in the input parameters of this class.

        This is used explicitly with the FirmataExpress sketch.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            # print(&#39;\nChecking {}&#39;.format(port.device))
            try:
                self.serial_port = PymataExpressSerial(port.device, self.baud_rate,
                                                       express_instance=self,
                                                       close_loop_on_error=self.close_loop_on_shutdown)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            serial_ports.append(self.serial_port)

            # display to the user
            print(&#39;\t&#39; + port.device)

            # clear out any possible data in the input buffer
            await self.serial_port.reset_input_buffer()

        # wait for arduino to reset
        print(&#39;\nWaiting {} seconds(arduino_wait) for Arduino devices to &#39;
              &#39;reset...&#39;.format(self.arduino_wait))
        await asyncio.sleep(self.arduino_wait)

        print(&#39;\nSearching for an Arduino configured with an arduino_instance = &#39;,
              self.arduino_instance_id)

        for serial_port in serial_ports:
            self.serial_port = serial_port
            # send the &#34;are you there&#34; sysex request to the arduino
            await self._send_sysex(PrivateConstants.ARE_YOU_THERE)

            # wait until the END_SYSEX comes back
            i_am_here = await self.serial_port.read_until(expected=b&#39;\xf7&#39;)
            if not i_am_here:
                continue

            # make sure we get back the expected length
            if len(i_am_here) != 4:
                continue

            # convert i_am_here to a list
            i_am_here = list(i_am_here)

            # check sysex command is I_AM_HERE
            if i_am_here[1] != PrivateConstants.I_AM_HERE:
                continue
            else:
                # got an I am here message - is it the correct ID?
                if i_am_here[2] == self.arduino_instance_id:
                    self.com_port = serial_port.com_port
                    self.using_firmata_express = True
                    return

    async def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        print(&#39;Opening {} ...&#39;.format(self.com_port))
        self.serial_port = PymataExpressSerial(self.com_port, self.baud_rate,
                                               express_instance=self,
                                               close_loop_on_error=self.close_loop_on_shutdown)

        print(&#39;Waiting {} seconds for the Arduino To Reset.&#39;
              .format(self.arduino_wait))
        await asyncio.sleep(self.arduino_wait)
        if self.baud_rate == 115200:
            await self._send_sysex(PrivateConstants.ARE_YOU_THERE)

            # await asyncio.sleep(1)
            # wait until the END_SYSEX comes back
            i_am_here = await self.serial_port.read_until(expected=b&#39;\xf7&#39;)

            # convert i_am_here to a list
            i_am_here = list(i_am_here)

            if len(i_am_here) != 4:
                raise RuntimeError(&#39;Invalid Arduino ID reply length&#39;)

            # check sysex command is I_AM_HERE
            if i_am_here[1] != PrivateConstants.I_AM_HERE:
                raise RuntimeError(&#39;Retrieving ID From Arduino Failed.&#39;)
            else:
                # got an I am here message - is it the correct ID?
                if i_am_here[2] == self.arduino_instance_id:
                    return
                else:
                    raise RuntimeError(&#39;Invalid Arduino identifier retrieved&#39;)

    async def analog_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified analog pin.

        :param pin: Analog pin number (ex. A2 is specified as 2)

        :returns:  [last value reported, time-stamp]
        &#34;&#34;&#34;

        return self.analog_pins[pin].current_value, self.analog_pins[pin].event_time

    async def analog_write(self, pin, value):
        &#34;&#34;&#34;
        This is an alias for PWM_write

        It may be removed in the future.

        Set the selected pin to the specified value.

        :param pin: Analog output pin number

        :param value: Pin value (0 - 0x4000)

        &#34;&#34;&#34;

        await self.pwm_write(pin, value)

    async def _analog_write_extended(self, pin, data):
        &#34;&#34;&#34;
        This method will send an extended-data analog write command to the
        selected pin.

        :param pin: 0 - 127

        :param data: 0 - 0xfffff

        :returns: No return value
        &#34;&#34;&#34;
        analog_data = [pin, data &amp; 0x7f, (data &gt;&gt; 7) &amp; 0x7f,
                       (data &gt;&gt; 14) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.EXTENDED_ANALOG, analog_data)

    async def digital_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified digital pin.

        :param pin: Digital pin number

        :returns:  [last value reported, time-stamp]

        &#34;&#34;&#34;
        return self.digital_pins[pin].current_value, self.digital_pins[pin].event_time

    async def dht_read(self, pin):
        &#34;&#34;&#34;
        Retrieve the last data update for the specified dht pin.

        :param pin: digital pin number

        :return: list = [humidity, temperature  time_stamp]

        &#34;&#34;&#34;
        return self.digital_pins[pin].current_value[0], \
               self.digital_pins[pin].current_value[1], \
               self.digital_pins[pin].event_time

    async def digital_pin_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value directly without port manipulation.

        :param pin: arduino pin number

        :param value: pin value

        &#34;&#34;&#34;

        command = (PrivateConstants.SET_DIGITAL_PIN_VALUE, pin, value)

        await self._send_command(command)

    async def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;
        # The command value is not a fixed value, but needs to be calculated
        # using the pin&#39;s port number
        port = pin // 8

        calculated_command = PrivateConstants.DIGITAL_MESSAGE + port
        mask = 1 &lt;&lt; (pin % 8)
        # Calculate the value for the pin&#39;s position in the port mask
        if value == 1:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] |= mask
        else:
            PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp;= ~mask

        # Assemble the command
        command = (calculated_command,
                   PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp; 0x7f,
                   (PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &gt;&gt; 7)
                   &amp; 0x7f)

        await self._send_command(command)

    async def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for A0, the number is 0.

        &#34;&#34;&#34;
        pin = pin + self.first_analog_pin
        await self.set_pin_mode_digital_input(pin)

    async def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting. By turning reporting off for this pin,
        Reporting is disabled for all 8 bits in the &#34;port&#34;

        :param pin: Pin and all pins for this port

        &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_DISABLE]
        await self._send_command(command)

    async def enable_analog_reporting(self, pin, callback=None, differential=1):
        &#34;&#34;&#34;
        Enables analog reporting. This is an alias for set_pin_mode_analog

        :param pin: Analog pin number. For example for A0, the number is 0.

        :param callback: async callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.
        &#34;&#34;&#34;
        await self.set_pin_mode_analog_input(pin, callback, differential)

    async def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enables digital reporting. By turning reporting on for all 8 bits
        in the &#34;port&#34; - this is part of Firmata&#39;s protocol specification.

        :param pin: Pin and all pins for this port

        :returns: No return value
            &#34;&#34;&#34;
        port = pin // 8
        command = [PrivateConstants.REPORT_DIGITAL + port,
                   PrivateConstants.REPORTING_ENABLE]
        await self._send_command(command)

    async def get_analog_map(self):
        &#34;&#34;&#34;
        This method requests a Firmata analog map query and returns the
        results.

        :returns: An analog map response or None if a timeout occurs
        &#34;&#34;&#34;
        # get the current time to make sure a report is retrieved
        current_time = time.time()

        # if we do not have existing report results, send a Firmata
        # message to request one
        if self.query_reply_data.get(
                PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
            await self._send_sysex(PrivateConstants.ANALOG_MAPPING_QUERY)
            # wait for the report results to return for 4 seconds
            # if the timer expires, return None
            while self.query_reply_data.get(
                    PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
                elapsed_time = time.time()
                if elapsed_time - current_time &gt; 4:
                    return None
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(
            PrivateConstants.ANALOG_MAPPING_RESPONSE)

    async def get_capability_report(self):
        &#34;&#34;&#34;
        This method requests and returns a Firmata capability query report

        :returns: A capability report in the form of a list
        &#34;&#34;&#34;
        if self.query_reply_data.get(
                PrivateConstants.CAPABILITY_RESPONSE) is None:
            await self._send_sysex(PrivateConstants.CAPABILITY_QUERY)
            while self.query_reply_data.get(
                    PrivateConstants.CAPABILITY_RESPONSE) is None:
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.CAPABILITY_RESPONSE)

    async def get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the Firmata firmware version

        :returns: Firmata firmware version
        &#34;&#34;&#34;
        current_time = time.time()
        if self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
            await self._send_sysex(PrivateConstants.REPORT_FIRMWARE)
            while self.query_reply_data.get(
                    PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
                elapsed_time = time.time()
                if elapsed_time - current_time &gt; 4:
                    return None
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE)

    async def get_protocol_version(self):
        &#34;&#34;&#34;
        This method returns the major and minor values for the protocol
        version, i.e. 2.5

        :returns: Firmata protocol version
        &#34;&#34;&#34;
        if self.query_reply_data.get(PrivateConstants.REPORT_VERSION) == &#39;&#39;:
            await self._send_command([PrivateConstants.REPORT_VERSION])
            while self.query_reply_data.get(
                    PrivateConstants.REPORT_VERSION) == &#39;&#39;:
                await asyncio.sleep(self.sleep_tune)
        return self.query_reply_data.get(PrivateConstants.REPORT_VERSION)

    async def get_pin_state(self, pin):
        &#34;&#34;&#34;
        This method retrieves a pin state report for the specified pin.
        Pin modes reported:

        INPUT   = 0x00  # digital input mode

        OUTPUT  = 0x01  # digital output mode

        ANALOG  = 0x02  # analog input mode

        PWM     = 0x03  # digital pin in PWM output mode

        SERVO   = 0x04  # digital pin in Servo output mode

        I2C     = 0x06  # pin included in I2C setup

        STEPPER = 0x08  # digital pin in stepper mode

        PULLUP  = 0x0b  # digital pin in input pullup mode

        SONAR   = 0x0c  # digital pin in SONAR mode

        TONE    = 0x0d  # digital pin in tone mode

        :param pin: Pin of interest

        :returns: pin state report

        &#34;&#34;&#34;
        # place pin in a list to keep _send_sysex happy
        await self._send_sysex(PrivateConstants.PIN_STATE_QUERY, [pin])
        while self.query_reply_data.get(
                PrivateConstants.PIN_STATE_RESPONSE) is None:
            await asyncio.sleep(self.sleep_tune)
        pin_state_report = self.query_reply_data.get(
            PrivateConstants.PIN_STATE_RESPONSE)
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = None
        return pin_state_report

    # noinspection PyMethodMayBeStatic
    async def get_pymata_version(self):
        &#34;&#34;&#34;
        This method retrieves the PyMata Express version number

        :returns: PyMata Express version number.
        &#34;&#34;&#34;
        return PrivateConstants.PYMATA_EXPRESS_VERSION

    async def i2c_read_saved_data(self, address):
        &#34;&#34;&#34;
        This method retrieves cached i2c data to support a polling mode.

        :param address: I2C device address

        :returns data: [raw data returned from i2c device, time-stamp]

        &#34;&#34;&#34;
        if address in self.i2c_map:
            map_entry = self.i2c_map.get(address)
            data = map_entry.get(&#39;value&#39;)
            return data
        else:
            return None

    async def i2c_read(self, address, register, number_of_bytes,
                       callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;

        await self._i2c_read_request(address, register, number_of_bytes,
                                     PrivateConstants.I2C_READ, callback)

    async def i2c_read_continuous(self, address, register, number_of_bytes,
                                  callback=None):
        &#34;&#34;&#34;
        Some i2c devices support a continuous streaming data output.
        This command enables that mode for the device that supports
        continuous reads.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;

        await self._i2c_read_request(address, register, number_of_bytes,
                                     PrivateConstants.I2C_READ_CONTINUOUSLY,
                                     callback)

    async def i2c_read_restart_transmission(self, address, register,
                                            number_of_bytes,
                                            callback=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device. This restarts the transmission after the read. It is
        required for some i2c devices such as the MMA8452Q accelerometer.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        callback returns a data list:

        [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

        The pin_type for i2c = 6

        &#34;&#34;&#34;

        await self._i2c_read_request(address, register, number_of_bytes,
                                     PrivateConstants.I2C_READ
                                     | PrivateConstants.I2C_END_TX_MASK,
                                     callback)

    async def _i2c_read_request(self, address, register, number_of_bytes, read_type,
                                callback=None):
        &#34;&#34;&#34;
        This method requests the read of an i2c device. Results are retrieved
        by a call to i2c_get_read_data(). or by callback.

        If a callback method is provided, when data is received from the
        device it will be sent to the callback method.

        Some devices require that transmission be restarted
        (e.g. MMA8452Q accelerometer).

        I2C_READ | I2C_END_TX_MASK values for the read_type in those cases.

        I2C_READ = 0B00001000

        I2C_READ_CONTINUOUSLY = 0B00010000

        I2C_STOP_READING = 0B00011000

        I2C_END_TX_MASK = 0B01000000

        :param address: i2c device address

        :param register: register number (can be set to zero or None)

        :param number_of_bytes: number of bytes expected to be returned

        :param read_type: I2C_READ  or I2C_READ_CONTINUOUSLY. I2C_END_TX_MASK
                          may be OR&#39;ed when required

        :param callback: Optional callback function to report i2c data as a
                   result of read command

        &#34;&#34;&#34;
        if address not in self.i2c_map:
            self.i2c_map[address] = {&#39;value&#39;: None, &#39;callback&#39;: callback}
        if register is not None:
            data = [address, read_type, register &amp; 0x7f, (register &gt;&gt; 7) &amp; 0x7f,
                    number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
        else:
            data = [address, read_type,
                    number_of_bytes &amp; 0x7f, (number_of_bytes &gt;&gt; 7) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    async def i2c_write(self, address, args):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list

        &#34;&#34;&#34;
        data = [address, PrivateConstants.I2C_WRITE]
        for item in args:
            item_lsb = item &amp; 0x7f
            data.append(item_lsb)
            item_msb = (item &gt;&gt; 7) &amp; 0x7f
            data.append(item_msb)
        await self._send_sysex(PrivateConstants.I2C_REQUEST, data)

    async def keep_alive(self, period=1, margin=.3):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Periodically send a keep alive message to the Arduino.

        If the Arduino does not received a keep alive, the Arduino
        will physically reset itself.

        Frequency of keep alive transmission is calculated as follows:
        keep_alive_sent = period - (period * margin)


        :param period: Time period between keepalives. Range is 0-10 seconds.
                       0 disables the keepalive mechanism.

        :param margin: Safety margin to assure keepalives are sent before
                    period expires. Range is 0.1 to 0.9
        &#34;&#34;&#34;

        self.period = period
        self.margin = margin
        if period &lt; 0:
            period = 0

        # if there is a currently running keep alive task
        # and the the period is 0, kill the task and return
        if period == 0 and self.keep_alive_task:
            self.keep_alive_task.cancel()
            return

        self.keep_alive_interval = period &amp; 0x7f, (period &gt;&gt; 7) &amp; 0x7f
        # if there is no keep alive task, start one
        if not self.keep_alive_task:
            self.keep_alive_task = self.loop.create_task(
                self._send_keep_alive())

    async def play_tone(self, pin_number, frequency, duration):
        &#34;&#34;&#34;

        This is FirmataExpress feature

        Play a tone at the specified frequency for the specified duration.

        :param pin_number: arduino pin number

        :param frequency: tone frequency in hz

        :param duration: duration in milliseconds

        &#34;&#34;&#34;
        await self._play_tone(pin_number, PrivateConstants.TONE_TONE, frequency=frequency,
                              duration=duration)

    async def play_tone_continuously(self, pin_number, frequency):
        &#34;&#34;&#34;

        This is a FirmataExpress feature

        This method plays a tone continuously until play_tone_off is called.

        :param pin_number: arduino pin number

        :param frequency: tone frequency in hz

        &#34;&#34;&#34;

        await self._play_tone(pin_number, PrivateConstants.TONE_TONE, frequency=frequency,
                              duration=None)

    async def play_tone_off(self, pin_number):
        &#34;&#34;&#34;
        This is a FirmataExpress Feature

        This method turns tone off for the specified pin.

        :param pin_number: arduino pin number

        &#34;&#34;&#34;

        await self._play_tone(pin_number, PrivateConstants.TONE_NO_TONE,
                              frequency=None, duration=None)

    async def _play_tone(self, pin, tone_command, frequency, duration):
        &#34;&#34;&#34;
        This method will call the Tone library for the selected pin.
        It requires FirmataPlus to be loaded onto the arduino

        If the tone command is set to TONE_TONE, then the specified
        tone will be played.

        Else, if the tone command is TONE_NO_TONE, then any currently
        playing tone will be disabled.

        :param pin: arduino pin number

        :param tone_command: Either TONE_TONE, or TONE_NO_TONE

        :param frequency: Frequency of tone

        :param duration: Duration of tone in milliseconds

        &#34;&#34;&#34;
        # convert the integer values to bytes
        if tone_command == PrivateConstants.TONE_TONE:
            # duration is specified
            if duration:
                data = [tone_command, pin, frequency &amp; 0x7f,
                        (frequency &gt;&gt; 7) &amp; 0x7f,
                        duration &amp; 0x7f, (duration &gt;&gt; 7) &amp; 0x7f]

            else:
                data = [tone_command, pin,
                        frequency &amp; 0x7f, (frequency &gt;&gt; 7) &amp; 0x7f, 0, 0]
        # turn off tone
        else:
            data = [tone_command, pin]
        await self._send_sysex(PrivateConstants.TONE_DATA, data)

    async def pwm_write(self, pin, value):
        &#34;&#34;&#34;
        This is an alias for PWM_write
        Set the selected pin to the specified value.

        :param pin: PWM pin number

        :param value: Pin value (0 - 0x4000)

        &#34;&#34;&#34;
        if PrivateConstants.ANALOG_MESSAGE + pin &lt; 0xf0:
            command = [PrivateConstants.ANALOG_MESSAGE + pin, value &amp; 0x7f,
                       (value &gt;&gt; 7) &amp; 0x7f]
            await self._send_command(command)
        else:
            await self._analog_write_extended(pin, value)

    async def send_reset(self):
        &#34;&#34;&#34;
        Send a Sysex reset command to the arduino

        &#34;&#34;&#34;
        try:
            await self._send_command([PrivateConstants.SYSTEM_RESET])
        except RuntimeError:
            raise

    async def set_pin_mode_analog_input(self, pin_number, callback=None,
                                        differential=1):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param pin_number: arduino pin number

        :param callback: async callback function

        :param differential: This value needs to be met for a callback
                             to be invoked.

        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 2

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.ANALOG,
                                 callback=callback,
                                 differential=differential)

    async def set_pin_mode_dht(self, pin_number, sensor_type=22, differential=.1,
                               callback=None):
        &#34;&#34;&#34;
        Configure a DHT sensor prior to operation.
        Up to 6 DHT sensors are supported

        :param pin_number: digital pin number on arduino.

        :param sensor_type: type of dht sensor
                            Valid values = DHT11, DHT22,

        :param differential: This value needs to be met for a callback
                             to be invoked.

        :param callback: callback function

        callback: returns a data list:

        [pin_type, pin_number, DHT type, validation flag, humidity value, temperature
        raw_time_stamp]

        The pin_type for DHT input pins = 15

        Validation Flag Values:

            No Errors = 0

            Checksum Error = 1

            Timeout Error = 2

            Invalid Value = 999
        &#34;&#34;&#34;

        # if the pin is not currently associated with a DHT device
        # initialize it.
        if pin_number not in self.dht_list:
            self.dht_list.append(pin_number)
            self.digital_pins[pin_number].cb = callback
            self.digital_pins[pin_number].current_value = [0, 0]
            self.digital_pins[pin_number].differential = differential
            data = [pin_number, sensor_type]
            await self._send_sysex(PrivateConstants.DHT_CONFIG, data)
        else:
            # allow user to change the differential value
            self.digital_pins[pin_number].differential = differential

    async def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: arduino pin number

        :param callback: async callback function

        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 0

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.INPUT, callback)

    async def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: arduino pin number

        :param callback: async callback function

        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 11

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.PULLUP, callback)

    async def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: arduino pin number
        &#34;&#34;&#34;

        await self._set_pin_mode(pin_number, PrivateConstants.OUTPUT)

    # noinspection PyIncorrectDocstring
    async def set_pin_mode_i2c(self, read_delay_time=0):
        &#34;&#34;&#34;
        Establish the standard Arduino i2c pins for i2c utilization.

        NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
        This method initializes Firmata for I2c operations.

        :param read_delay_time (in microseconds): an optional parameter,
                                                  default is 0

        &#34;&#34;&#34;
        data = [read_delay_time &amp; 0x7f, (read_delay_time &gt;&gt; 7) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.I2C_CONFIG, data)

    async def set_pin_mode_pwm(self, pin_number):
        &#34;&#34;&#34;

        This is an alias for set_pin_mode_pwm_output.

        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        await self.set_pin_mode_pwm_output(pin_number)

    async def set_pin_mode_pwm_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        await self._set_pin_mode(pin_number, PrivateConstants.PWM)

    async def set_pin_mode_servo(self, pin, min_pulse=544, max_pulse=2400):
        &#34;&#34;&#34;
        Configure a pin as a servo pin. Set pulse min, max in ms.

        :param pin: Servo Pin.

        :param min_pulse: Min pulse width in ms.

        :param max_pulse: Max pulse width in ms.

        &#34;&#34;&#34;
        command = [pin, min_pulse &amp; 0x7f, (min_pulse &gt;&gt; 7) &amp; 0x7f,
                   max_pulse &amp; 0x7f,
                   (max_pulse &gt;&gt; 7) &amp; 0x7f]

        await self._send_sysex(PrivateConstants.SERVO_CONFIG, command)

    async def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                                 callback=None, timeout=80000):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Configure the pins,ping interval and maximum distance for an HC-SR04
        type device.

        Up to a maximum of 6 SONAR devices is supported.
        If the maximum is exceeded a message is sent to the console and the
        request is ignored.

        NOTE: data is measured in centimeters

        :param trigger_pin: The pin number of for the trigger (transmitter).

        :param echo_pin: The pin number for the received echo.

        :param callback: optional callback function to report sonar data changes

        :param timeout: a tuning parameter. 80000UL equals 80ms.

        callback returns a data list:

        [pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]

        The pin_type for sonar pins = 12


        &#34;&#34;&#34;
        # if there is an entry for the trigger pin in existence,
        # ignore the duplicate request.
        if trigger_pin in self.active_sonar_map:
            return

        timeout_lsb = timeout &amp; 0x7f
        timeout_msb = (timeout &gt;&gt; 7) &amp; 0x7f
        data = [trigger_pin, echo_pin, timeout_lsb,
                timeout_msb]

        await self._set_pin_mode(trigger_pin, PrivateConstants.SONAR,
                                 PrivateConstants.INPUT)
        await self._set_pin_mode(echo_pin, PrivateConstants.SONAR,
                                 PrivateConstants.INPUT)
        # update the ping data map for this pin
        if len(self.active_sonar_map) &gt; 6:
            print(&#39;sonar_config: maximum number of devices assigned&#39;
                  &#39; - ignoring request&#39;)
        else:
            self.active_sonar_map[trigger_pin] = [callback, 0, 0]

        await self._send_sysex(PrivateConstants.SONAR_CONFIG, data)

    async def set_pin_mode_stepper(self, steps_per_revolution, stepper_pins):
        &#34;&#34;&#34;
        This is a FirmataExpress feature.

        Configure stepper motor prior to operation.
        This is a FirmataPlus feature.

        NOTE: Single stepper only. Multiple steppers not supported.

        :param steps_per_revolution: number of steps per motor revolution

        :param stepper_pins: a list of control pin numbers - either 4 or 2

        &#34;&#34;&#34;
        data = [PrivateConstants.STEPPER_CONFIGURE,
                steps_per_revolution &amp; 0x7f,
                (steps_per_revolution &gt;&gt; 7) &amp; 0x7f]
        for pin in range(len(stepper_pins)):
            data.append(stepper_pins[pin])
        await self._send_sysex(PrivateConstants.STEPPER_DATA, data)

    async def set_pin_mode_tone(self, pin_number):
        &#34;&#34;&#34;
        This is FirmataExpress feature.

        Set a PWM pin to tone mode.

        :param pin_number: arduino pin number

        &#34;&#34;&#34;
        command = [PrivateConstants.SET_PIN_MODE, pin_number,
                   PrivateConstants.TONE]
        await self._send_command(command)

    async def _set_pin_mode(self, pin_number, pin_state, callback=None,
                            differential=1):
        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: arduino pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP - for SERVO use
                          servo_config()
                          For DHT   use: set_pin_mode_dht

        :param callback: A reference to an async call back function to be
                         called when pin data value changes

        :param differential: This value needs to be met for a callback
                             to be invoked

        &#34;&#34;&#34;

        # There is a potential start up race condition when running pymata3.
        # This is a workaround for that race condition
        #
        if not len(self.digital_pins):
            await asyncio.sleep(2)
        if callback:
            if pin_state == PrivateConstants.INPUT:
                self.digital_pins[pin_number].cb = callback
            elif pin_state == PrivateConstants.PULLUP:
                self.digital_pins[pin_number].cb = callback
                self.digital_pins[pin_number].pull_up = True
            elif pin_state == PrivateConstants.ANALOG:
                self.analog_pins[pin_number].cb = callback
                self.analog_pins[pin_number].differential = differential
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        pin_mode = pin_state

        if pin_mode == PrivateConstants.ANALOG:
            pin_number = pin_number + self.first_analog_pin

        command = [PrivateConstants.SET_PIN_MODE, pin_number, pin_mode]
        await self._send_command(command)

        if pin_state == PrivateConstants.INPUT or pin_state == PrivateConstants.PULLUP:
            await self.enable_digital_reporting(pin_number)
        else:
            pass

        await asyncio.sleep(.05)

    async def _send_keep_alive(self):
        &#34;&#34;&#34;
        This is a the task to continuously send keep alive messages
        &#34;&#34;&#34;
        while not self.shutdown_flag:
            if self.period:
                await self._send_sysex(PrivateConstants.KEEP_ALIVE,
                                       self.keep_alive_interval)

                # wait the requested amount of time before sending the next
                # keep alive to the Arduino
                await asyncio.sleep(self.period - self.margin)

    async def set_sampling_interval(self, interval):
        &#34;&#34;&#34;
        This method sends the desired sampling interval to Firmata.

        Note: Standard Firmata  will ignore any interval less than
              10 milliseconds

        :param interval: Integer value for desired sampling interval
                         in milliseconds

        &#34;&#34;&#34;
        data = [interval &amp; 0x7f, (interval &gt;&gt; 7) &amp; 0x7f]
        await self._send_sysex(PrivateConstants.SAMPLING_INTERVAL, data)

    async def servo_write(self, pin, position):
        &#34;&#34;&#34;
        This is an alias for pwm_write to set
        the position of a servo that has been
        previously configured using set_pin_mode_servo.

        :param pin: arduino pin number

        :param position: servo position

        &#34;&#34;&#34;

        await self.pwm_write(pin, position)

    async def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.

        &#34;&#34;&#34;

        self.shutdown_flag = True

        # stop all reporting - both analog and digital
        for pin in range(len(self.analog_pins)):
            await self.disable_analog_reporting(pin)

        for pin in range(len(self.digital_pins)):
            await self.disable_digital_reporting(pin)

        try:
            if self.close_loop_on_shutdown:
                self.loop.stop()
            await self.send_reset()
            await self.serial_port.reset_input_buffer()
            await self.serial_port.close()
            if self.close_loop_on_shutdown:
                self.loop.close()
        except (RuntimeError, SerialException):
            pass

    async def sonar_read(self, trigger_pin):
        &#34;&#34;&#34;
        This is a FirmataExpress feature

        Retrieve Ping (HC-SR04 type) data. The data is presented as a
        dictionary.

        The &#39;key&#39; is the trigger pin specified in sonar_config()
        and the &#39;data&#39; is the current measured distance (in centimeters)
        for that pin. If there is no data, the value is set to None.

        :param trigger_pin: key into sonar data map

        :returns: [last distance, raw time stamp]
        &#34;&#34;&#34;

        sonar_pin_entry = self.active_sonar_map.get(trigger_pin)
        return [sonar_pin_entry[1], sonar_pin_entry[2]]
        # value = sonar_pin_entry[1]
        # return value

    async def stepper_write(self, motor_speed, number_of_steps):
        &#34;&#34;&#34;
        This is a FirmataExpress feature

        Move a stepper motor for the number of steps at the specified speed.
        This is a FirmataPlus feature.

        :param motor_speed: 21 bits of data to set motor speed

        :param number_of_steps: 14 bits for number of steps &amp; direction
                                positive is forward, negative is reverse

        &#34;&#34;&#34;
        if number_of_steps &gt; 0:
            direction = 1
        else:
            direction = 0
        abs_number_of_steps = abs(number_of_steps)
        data = [PrivateConstants.STEPPER_STEP, motor_speed &amp; 0x7f,
                (motor_speed &gt;&gt; 7) &amp; 0x7f, (motor_speed &gt;&gt; 14) &amp; 0x7f,
                abs_number_of_steps &amp; 0x7f, (abs_number_of_steps &gt;&gt; 7) &amp; 0x7f,
                direction]
        await self._send_sysex(PrivateConstants.STEPPER_DATA, data)

    async def _arduino_report_dispatcher(self):
        &#34;&#34;&#34;
        This is a private method.
        It continually accepts and interprets data coming from Firmata,and then
        dispatches the correct handler to process the data.

        :returns: This method never returns
        &#34;&#34;&#34;
        # sysex commands are assembled into this list for processing
        sysex = []

        while True:
            if self.shutdown_flag:
                break
            try:
                if not self.ip_address:
                    next_command_byte = await self.serial_port.read()
                else:
                    next_command_byte = await self.socket_transport.read()

            except TypeError:
                continue
            # if this is a SYSEX command, then assemble the entire
            # command process it
            if next_command_byte == PrivateConstants.START_SYSEX:
                while next_command_byte != PrivateConstants.END_SYSEX:
                    if not self.ip_address:
                        next_command_byte = await self.serial_port.read()
                    else:
                        next_command_byte = await self.socket_transport.read()
                    sysex.append(next_command_byte)
                await self.command_dictionary[sysex[0]](sysex)
                sysex = []
            # if this is an analog message, process it.
            elif 0xE0 &lt;= next_command_byte &lt;= 0xEF:
                # analog message
                # assemble the entire analog message in command
                command = []
                # get the pin number for the message
                pin = next_command_byte &amp; 0x0f
                command.append(pin)
                # get the next 2 bytes for the command
                command = await self._wait_for_data(command, 2)
                # process the analog message
                await self._analog_message(command)
            # handle the digital message
            elif 0x90 &lt;= next_command_byte &lt;= 0x9F:
                command = []
                port = next_command_byte &amp; 0x0f
                command.append(port)
                command = await self._wait_for_data(command, 2)
                await self._digital_message(command)
            # handle all other messages by looking them up in the
            # command dictionary
            elif next_command_byte in self.command_dictionary:
                await self.command_dictionary[next_command_byte]()
                await asyncio.sleep(self.sleep_tune)
            else:
                continue

    &#39;&#39;&#39;
    Firmata message handlers
    &#39;&#39;&#39;

    async def _analog_mapping_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for the analog mapping response message.

        :param data: response data

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.ANALOG_MAPPING_RESPONSE] = \
            data[1:-1]

    async def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[PrivateConstants.MSB] &lt;&lt; 7) + data[PrivateConstants.LSB]

        # only report when there is a change in value
        differential = abs(value - self.analog_pins[pin].current_value)
        if differential &gt;= self.analog_pins[pin].differential:
            self.analog_pins[pin].current_value = value
            time_stamp = time.time()
            self.analog_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            message = [PrivateConstants.ANALOG, pin, value, time_stamp]

            if self.analog_pins[pin].cb:
                # if self.analog_pins[pin].cb_type:
                await self.analog_pins[pin].cb(message)

    async def _capability_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for capability report responses.

        :param data: capability report

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.CAPABILITY_RESPONSE] = data[1:-1]

    async def _dht_read_response(self, data):
        &#34;&#34;&#34;
        Process the dht response message.

        Values are calculated using:
                humidity = (_bits[0] * 256 + _bits[1]) * 0.1

                temperature = ((_bits[2] &amp; 0x7F) * 256 + _bits[3]) * 0.1

        error codes:
        0 - OK
        1 - DHTLIB_ERROR_TIMEOUT
        2 - Checksum error

        :param: data: [Report Type, pin, dht_type, validation_flag, humidity, temperature]
        &#34;&#34;&#34;

        # get the time of the report
        time_stamp = time.time()

        # adjust data to just show values from sensor
        data = data[1:-1]
        # initiate a list for a potential call back
        reply_data = [PrivateConstants.DHT]

        # get the pin and type of the dht
        pin = data[0]
        reply_data.append(pin)
        dht_type = data[1]
        reply_data.append(dht_type)
        humidity = temperature = 0

        if data[2] == 0:  # all is well
            humidity = float(data[3] + data[4] / 10)
            temperature = float(data[5] + data[6] / 10)

        self.digital_pins[pin].event_time = time_stamp
        reply_data.append(data[2])
        reply_data.append(humidity)
        reply_data.append(temperature)
        reply_data.append(time_stamp)

        # retrieve the last reported values
        last_value = self.digital_pins[pin].current_value

        self.digital_pins[pin].current_value = [humidity, temperature]
        if self.digital_pins[pin].cb:
            # only report changes
            # has the humidity changed?
            if last_value[0] != humidity:

                differential = abs(humidity - last_value[0])
                if differential &gt;= self.digital_pins[pin].differential:
                    await self.digital_pins[pin].cb(reply_data)
                return
            if last_value[1] != temperature:
                differential = abs(temperature - last_value[1])
                if differential &gt;= self.digital_pins[pin].differential:
                    await self.digital_pins[pin].cb(reply_data)
                return

    async def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        port = data[0]
        # noinspection PyPep8,PyPep8
        port_data = (data[PrivateConstants.MSB] &lt;&lt; 7) + \
                    data[PrivateConstants.LSB]
        pin = port * 8
        for pin in range(pin, min(pin + 8, len(self.digital_pins))):
            # get pin value
            value = port_data &amp; 0x01

            last_value = self.digital_pins[pin].current_value

            # set the current value in the pin structure
            self.digital_pins[pin].current_value = value
            time_stamp = time.time()
            self.digital_pins[pin].event_time = time_stamp

            # append pin number, pin value, and pin type to return value and return as a list
            # if self.legacy_mode:
            #     message = [pin, value, PrivateConstants.INPUT, time_stamp]
            # else:
            if self.digital_pins[pin].pull_up:
                message = [PrivateConstants.PULLUP, pin, value, time_stamp]
            else:
                message = [PrivateConstants.INPUT, pin, value, time_stamp]

            if last_value != value:
                if self.digital_pins[pin].cb:
                    await self.digital_pins[pin].cb(message)

            port_data &gt;&gt;= 1

    async def _i2c_reply(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles replies to i2c_read requests. It stores the data
        for each i2c device address in a dictionary called i2c_map.
        The data may be retrieved via a polling call to i2c_get_read_data().
        It a callback was specified in pymata.i2c_read, the raw data is sent
        through the callback

        :param data: raw data returned from i2c device

        &#34;&#34;&#34;
        # remove the start and end sysex commands from the data
        data = data[1:-1]
        reply_data = [PrivateConstants.I2C]
        # reassemble the data from the firmata 2 byte format
        address = (data[0] &amp; 0x7f) + (data[1] &lt;&lt; 7)

        # if we have an entry in the i2c_map, proceed
        if address in self.i2c_map:
            # get 2 bytes, combine them and append to reply data list
            for i in range(0, len(data), 2):
                combined_data = (data[i] &amp; 0x7f) + (data[i + 1] &lt;&lt; 7)
                reply_data.append(combined_data)

            current_time = time.time()
            reply_data.append(current_time)

            # place the data in the i2c map without storing the address byte or
            #  register byte (returned data only)
            map_entry = self.i2c_map.get(address)
            map_entry[&#39;value&#39;] = reply_data[2:]
            map_entry[&#39;time_stamp&#39;] = current_time
            self.i2c_map[address] = map_entry
            cb = map_entry.get(&#39;callback&#39;)
            if cb:
                # send everything, including address and register bytes back
                # to caller
                await cb(reply_data)

    async def _pin_state_response(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It handles pin state query response messages.

        :param data: Pin state message

        &#34;&#34;&#34;
        self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = data[1:-1]

    async def _report_firmware(self, sysex_data):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method handles the sysex &#39;report firmware&#39; command sent by
        Firmata (0x79).

        It assembles the firmware version by concatenating the major and
        minor version number components and the firmware identifier into
        a string.

        e.g. &#34;2.3 StandardFirmata.ino&#34;

        :param sysex_data: Sysex data sent from Firmata

        &#34;&#34;&#34;
        # first byte after command is major number
        major = sysex_data[1]
        version_string = str(major)

        # next byte is minor number
        minor = sysex_data[2]

        # append a dot to major number
        version_string += &#39;.&#39;

        # append minor number
        version_string += str(minor)
        # add a space after the major and minor numbers
        version_string += &#39; &#39;

        # slice the identifier - from the first byte after the minor
        #  number up until, but not including the END_SYSEX byte

        name = sysex_data[3:-1]
        firmware_name_iterator = iter(name)

        # convert each element from two 7-bit bytes into characters, then add each
        # character to the version string
        for e in firmware_name_iterator:
            version_string += chr(e + (next(firmware_name_iterator) &lt;&lt; 7))

        # store the value
        self.query_reply_data[PrivateConstants.REPORT_FIRMWARE] = version_string

    async def _report_version(self):
        &#34;&#34;&#34;
        This is a private message handler method.

        This method reads the following 2 bytes after the report version
        command (0xF9 - non sysex).

        The first byte is the major number and the second byte is the
        minor number.

        &#34;&#34;&#34;
        # get next two bytes
        if not self.ip_address:
            major = await self.serial_port.read()
        else:
            major = await self.socket_transport.read()
        version_string = str(major)

        if not self.ip_address:
            minor = await self.serial_port.read()
        else:
            minor = await self.socket_transport.read()

        version_string += &#39;.&#39;
        version_string += str(minor)
        self.query_reply_data[PrivateConstants.REPORT_VERSION] = version_string

    async def _sonar_data(self, data):
        &#34;&#34;&#34;
        This method handles the incoming sonar data message and stores
        the data in the response table.

        :param data: Message data from Firmata

        &#34;&#34;&#34;

        # strip off sysex start and end
        data = data[1:-1]
        pin_number = data[0]
        val = int((data[PrivateConstants.MSB] &lt;&lt; 7) +
                  data[PrivateConstants.LSB])
        reply_data = [PrivateConstants.SONAR]

        sonar_pin_entry = self.active_sonar_map[pin_number]

        if sonar_pin_entry[0] is not None:
            # check if value changed since last reading
            if sonar_pin_entry[1] != val:
                sonar_pin_entry[1] = val
                time_stamp = time.time()
                sonar_pin_entry[2] = time_stamp
                self.active_sonar_map[pin_number] = sonar_pin_entry
                # Do a callback if one is specified in the table
                if sonar_pin_entry[0]:
                    reply_data.append(pin_number)
                    reply_data.append(val)
                    reply_data.append(time_stamp)

                    if sonar_pin_entry[1]:
                        await sonar_pin_entry[0](reply_data)

        # update the data in the table with latest value
        else:
            sonar_pin_entry[1] = val
            self.active_sonar_map[pin_number] = sonar_pin_entry

        await asyncio.sleep(self.sleep_tune)

    async def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.
        The method sends a non-sysex command to Firmata.

        :param command:  command data

        :returns: number of bytes sent
        &#34;&#34;&#34;
        send_message = &#34;&#34;

        for i in command:
            send_message += chr(i)
        result = None
        if not self.ip_address:
            for data in send_message:
                try:
                    result = await self.serial_port.write(data)
                except AttributeError:
                    raise RuntimeError
        else:
            for data in send_message:
                try:
                    result = await self.socket_transport.write(data)
                except AttributeError:
                    raise RuntimeError

        return result

    async def _send_sysex(self, sysex_command, sysex_data=None):
        &#34;&#34;&#34;
        This is a private utility method.
        This method sends a sysex command to Firmata.

        :param sysex_command: sysex command

        :param sysex_data: data for command

        &#34;&#34;&#34;
        if not sysex_data:
            sysex_data = []

        # convert the message command and data to characters
        sysex_message = chr(PrivateConstants.START_SYSEX)
        sysex_message += chr(sysex_command)
        if len(sysex_data):
            for d in sysex_data:
                sysex_message += chr(d)
        sysex_message += chr(PrivateConstants.END_SYSEX)

        if not self.ip_address:
            for data in sysex_message:
                await self.serial_port.write(data)
        else:
            await self.socket_transport.write(sysex_message)
            await asyncio.sleep(.01)

        # noinspection PyMethodMayBeStatic

    # noinspection PyMethodMayBeStatic
    async def _string_data(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is the message handler for String data messages that will be
        printed to the console.

        :param data:  message

        &#34;&#34;&#34;
        reply = &#39;&#39;
        data = data[1:-1]
        for x in data:
            reply_data = x
            if reply_data:
                reply += chr(reply_data)
        print(reply)

    async def _wait_for_data(self, current_command, number_of_bytes):
        &#34;&#34;&#34;
        This is a private utility method.
        This method accumulates the requested number of bytes and
        then returns the full command

        :param current_command:  command id

        :param number_of_bytes:  how many bytes to wait for

        :returns: command
        &#34;&#34;&#34;
        while number_of_bytes:
            if not self.ip_address:
                next_command_byte = await self.serial_port.read()
                current_command.append(next_command_byte)
                number_of_bytes -= 1
            else:
                next_command_byte = await self.socket_transport.read()
                current_command.append(next_command_byte)
                number_of_bytes -= 1
        return current_command</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pymata_express.pymata_express.PymataExpress.analog_read"><code class="name flex">
<span>async def <span class="ident">analog_read</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the last data update for the specified analog pin.</p>
<p>:param pin: Analog pin number (ex. A2 is specified as 2)</p>
<p>:returns:
[last value reported, time-stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def analog_read(self, pin):
    &#34;&#34;&#34;
    Retrieve the last data update for the specified analog pin.

    :param pin: Analog pin number (ex. A2 is specified as 2)

    :returns:  [last value reported, time-stamp]
    &#34;&#34;&#34;

    return self.analog_pins[pin].current_value, self.analog_pins[pin].event_time</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.analog_write"><code class="name flex">
<span>async def <span class="ident">analog_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an alias for PWM_write</p>
<p>It may be removed in the future.</p>
<p>Set the selected pin to the specified value.</p>
<p>:param pin: Analog output pin number</p>
<p>:param value: Pin value (0 - 0x4000)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def analog_write(self, pin, value):
    &#34;&#34;&#34;
    This is an alias for PWM_write

    It may be removed in the future.

    Set the selected pin to the specified value.

    :param pin: Analog output pin number

    :param value: Pin value (0 - 0x4000)

    &#34;&#34;&#34;

    await self.pwm_write(pin, value)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.dht_read"><code class="name flex">
<span>async def <span class="ident">dht_read</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the last data update for the specified dht pin.</p>
<p>:param pin: digital pin number</p>
<p>:return: list = [humidity, temperature
time_stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dht_read(self, pin):
    &#34;&#34;&#34;
    Retrieve the last data update for the specified dht pin.

    :param pin: digital pin number

    :return: list = [humidity, temperature  time_stamp]

    &#34;&#34;&#34;
    return self.digital_pins[pin].current_value[0], \
           self.digital_pins[pin].current_value[1], \
           self.digital_pins[pin].event_time</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.digital_pin_write"><code class="name flex">
<span>async def <span class="ident">digital_pin_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the specified pin to the specified value directly without port manipulation.</p>
<p>:param pin: arduino pin number</p>
<p>:param value: pin value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def digital_pin_write(self, pin, value):
    &#34;&#34;&#34;
    Set the specified pin to the specified value directly without port manipulation.

    :param pin: arduino pin number

    :param value: pin value

    &#34;&#34;&#34;

    command = (PrivateConstants.SET_DIGITAL_PIN_VALUE, pin, value)

    await self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.digital_read"><code class="name flex">
<span>async def <span class="ident">digital_read</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the last data update for the specified digital pin.</p>
<p>:param pin: Digital pin number</p>
<p>:returns:
[last value reported, time-stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def digital_read(self, pin):
    &#34;&#34;&#34;
    Retrieve the last data update for the specified digital pin.

    :param pin: Digital pin number

    :returns:  [last value reported, time-stamp]

    &#34;&#34;&#34;
    return self.digital_pins[pin].current_value, self.digital_pins[pin].event_time</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.digital_write"><code class="name flex">
<span>async def <span class="ident">digital_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the specified pin to the specified value.</p>
<p>:param pin: arduino pin number</p>
<p>:param value: pin value (1 or 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def digital_write(self, pin, value):
    &#34;&#34;&#34;
    Set the specified pin to the specified value.

    :param pin: arduino pin number

    :param value: pin value (1 or 0)

    &#34;&#34;&#34;
    # The command value is not a fixed value, but needs to be calculated
    # using the pin&#39;s port number
    port = pin // 8

    calculated_command = PrivateConstants.DIGITAL_MESSAGE + port
    mask = 1 &lt;&lt; (pin % 8)
    # Calculate the value for the pin&#39;s position in the port mask
    if value == 1:
        PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] |= mask
    else:
        PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp;= ~mask

    # Assemble the command
    command = (calculated_command,
               PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &amp; 0x7f,
               (PrivateConstants.DIGITAL_OUTPUT_PORT_PINS[port] &gt;&gt; 7)
               &amp; 0x7f)

    await self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.disable_analog_reporting"><code class="name flex">
<span>async def <span class="ident">disable_analog_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables analog reporting for a single analog pin.</p>
<p>:param pin: Analog pin number. For example for A0, the number is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disable_analog_reporting(self, pin):
    &#34;&#34;&#34;
    Disables analog reporting for a single analog pin.

    :param pin: Analog pin number. For example for A0, the number is 0.

    &#34;&#34;&#34;
    pin = pin + self.first_analog_pin
    await self.set_pin_mode_digital_input(pin)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.disable_digital_reporting"><code class="name flex">
<span>async def <span class="ident">disable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables digital reporting. By turning reporting off for this pin,
Reporting is disabled for all 8 bits in the "port"</p>
<p>:param pin: Pin and all pins for this port</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Disables digital reporting. By turning reporting off for this pin,
    Reporting is disabled for all 8 bits in the &#34;port&#34;

    :param pin: Pin and all pins for this port

    &#34;&#34;&#34;
    port = pin // 8
    command = [PrivateConstants.REPORT_DIGITAL + port,
               PrivateConstants.REPORTING_DISABLE]
    await self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.enable_analog_reporting"><code class="name flex">
<span>async def <span class="ident">enable_analog_reporting</span></span>(<span>self, pin, callback=None, differential=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables analog reporting. This is an alias for set_pin_mode_analog</p>
<p>:param pin: Analog pin number. For example for A0, the number is 0.</p>
<p>:param callback: async callback function</p>
<p>:param differential: This value needs to be met for a callback
to be invoked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def enable_analog_reporting(self, pin, callback=None, differential=1):
    &#34;&#34;&#34;
    Enables analog reporting. This is an alias for set_pin_mode_analog

    :param pin: Analog pin number. For example for A0, the number is 0.

    :param callback: async callback function

    :param differential: This value needs to be met for a callback
                         to be invoked.
    &#34;&#34;&#34;
    await self.set_pin_mode_analog_input(pin, callback, differential)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.enable_digital_reporting"><code class="name flex">
<span>async def <span class="ident">enable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables digital reporting. By turning reporting on for all 8 bits
in the "port" - this is part of Firmata's protocol specification.</p>
<p>:param pin: Pin and all pins for this port</p>
<p>:returns: No return value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def enable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Enables digital reporting. By turning reporting on for all 8 bits
    in the &#34;port&#34; - this is part of Firmata&#39;s protocol specification.

    :param pin: Pin and all pins for this port

    :returns: No return value
        &#34;&#34;&#34;
    port = pin // 8
    command = [PrivateConstants.REPORT_DIGITAL + port,
               PrivateConstants.REPORTING_ENABLE]
    await self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.get_analog_map"><code class="name flex">
<span>async def <span class="ident">get_analog_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method requests a Firmata analog map query and returns the
results.</p>
<p>:returns: An analog map response or None if a timeout occurs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_analog_map(self):
    &#34;&#34;&#34;
    This method requests a Firmata analog map query and returns the
    results.

    :returns: An analog map response or None if a timeout occurs
    &#34;&#34;&#34;
    # get the current time to make sure a report is retrieved
    current_time = time.time()

    # if we do not have existing report results, send a Firmata
    # message to request one
    if self.query_reply_data.get(
            PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
        await self._send_sysex(PrivateConstants.ANALOG_MAPPING_QUERY)
        # wait for the report results to return for 4 seconds
        # if the timer expires, return None
        while self.query_reply_data.get(
                PrivateConstants.ANALOG_MAPPING_RESPONSE) is None:
            elapsed_time = time.time()
            if elapsed_time - current_time &gt; 4:
                return None
            await asyncio.sleep(self.sleep_tune)
    return self.query_reply_data.get(
        PrivateConstants.ANALOG_MAPPING_RESPONSE)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.get_capability_report"><code class="name flex">
<span>async def <span class="ident">get_capability_report</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method requests and returns a Firmata capability query report</p>
<p>:returns: A capability report in the form of a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_capability_report(self):
    &#34;&#34;&#34;
    This method requests and returns a Firmata capability query report

    :returns: A capability report in the form of a list
    &#34;&#34;&#34;
    if self.query_reply_data.get(
            PrivateConstants.CAPABILITY_RESPONSE) is None:
        await self._send_sysex(PrivateConstants.CAPABILITY_QUERY)
        while self.query_reply_data.get(
                PrivateConstants.CAPABILITY_RESPONSE) is None:
            await asyncio.sleep(self.sleep_tune)
    return self.query_reply_data.get(PrivateConstants.CAPABILITY_RESPONSE)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.get_event_loop"><code class="name flex">
<span>async def <span class="ident">get_event_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the currently active asyncio event loop</p>
<p>:return: Active event loop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_event_loop(self):
    &#34;&#34;&#34;
    Return the currently active asyncio event loop

    :return: Active event loop

    &#34;&#34;&#34;
    return self.loop</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.get_firmware_version"><code class="name flex">
<span>async def <span class="ident">get_firmware_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves the Firmata firmware version</p>
<p>:returns: Firmata firmware version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_firmware_version(self):
    &#34;&#34;&#34;
    This method retrieves the Firmata firmware version

    :returns: Firmata firmware version
    &#34;&#34;&#34;
    current_time = time.time()
    if self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
        await self._send_sysex(PrivateConstants.REPORT_FIRMWARE)
        while self.query_reply_data.get(
                PrivateConstants.REPORT_FIRMWARE) == &#39;&#39;:
            elapsed_time = time.time()
            if elapsed_time - current_time &gt; 4:
                return None
            await asyncio.sleep(self.sleep_tune)
    return self.query_reply_data.get(PrivateConstants.REPORT_FIRMWARE)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.get_pin_state"><code class="name flex">
<span>async def <span class="ident">get_pin_state</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves a pin state report for the specified pin.
Pin modes reported:</p>
<p>INPUT
= 0x00
# digital input mode</p>
<p>OUTPUT
= 0x01
# digital output mode</p>
<p>ANALOG
= 0x02
# analog input mode</p>
<p>PWM
= 0x03
# digital pin in PWM output mode</p>
<p>SERVO
= 0x04
# digital pin in Servo output mode</p>
<p>I2C
= 0x06
# pin included in I2C setup</p>
<p>STEPPER = 0x08
# digital pin in stepper mode</p>
<p>PULLUP
= 0x0b
# digital pin in input pullup mode</p>
<p>SONAR
= 0x0c
# digital pin in SONAR mode</p>
<p>TONE
= 0x0d
# digital pin in tone mode</p>
<p>:param pin: Pin of interest</p>
<p>:returns: pin state report</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_pin_state(self, pin):
    &#34;&#34;&#34;
    This method retrieves a pin state report for the specified pin.
    Pin modes reported:

    INPUT   = 0x00  # digital input mode

    OUTPUT  = 0x01  # digital output mode

    ANALOG  = 0x02  # analog input mode

    PWM     = 0x03  # digital pin in PWM output mode

    SERVO   = 0x04  # digital pin in Servo output mode

    I2C     = 0x06  # pin included in I2C setup

    STEPPER = 0x08  # digital pin in stepper mode

    PULLUP  = 0x0b  # digital pin in input pullup mode

    SONAR   = 0x0c  # digital pin in SONAR mode

    TONE    = 0x0d  # digital pin in tone mode

    :param pin: Pin of interest

    :returns: pin state report

    &#34;&#34;&#34;
    # place pin in a list to keep _send_sysex happy
    await self._send_sysex(PrivateConstants.PIN_STATE_QUERY, [pin])
    while self.query_reply_data.get(
            PrivateConstants.PIN_STATE_RESPONSE) is None:
        await asyncio.sleep(self.sleep_tune)
    pin_state_report = self.query_reply_data.get(
        PrivateConstants.PIN_STATE_RESPONSE)
    self.query_reply_data[PrivateConstants.PIN_STATE_RESPONSE] = None
    return pin_state_report</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.get_protocol_version"><code class="name flex">
<span>async def <span class="ident">get_protocol_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the major and minor values for the protocol
version, i.e. 2.5</p>
<p>:returns: Firmata protocol version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_protocol_version(self):
    &#34;&#34;&#34;
    This method returns the major and minor values for the protocol
    version, i.e. 2.5

    :returns: Firmata protocol version
    &#34;&#34;&#34;
    if self.query_reply_data.get(PrivateConstants.REPORT_VERSION) == &#39;&#39;:
        await self._send_command([PrivateConstants.REPORT_VERSION])
        while self.query_reply_data.get(
                PrivateConstants.REPORT_VERSION) == &#39;&#39;:
            await asyncio.sleep(self.sleep_tune)
    return self.query_reply_data.get(PrivateConstants.REPORT_VERSION)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.get_pymata_version"><code class="name flex">
<span>async def <span class="ident">get_pymata_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves the PyMata Express version number</p>
<p>:returns: PyMata Express version number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_pymata_version(self):
    &#34;&#34;&#34;
    This method retrieves the PyMata Express version number

    :returns: PyMata Express version number.
    &#34;&#34;&#34;
    return PrivateConstants.PYMATA_EXPRESS_VERSION</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.i2c_read"><code class="name flex">
<span>async def <span class="ident">i2c_read</span></span>(<span>self, address, register, number_of_bytes, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified register for
the i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Optional callback function to report i2c data as a
result of read command</p>
<p>callback returns a data list:</p>
<p>[pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]</p>
<p>The pin_type for i2c = 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def i2c_read(self, address, register, number_of_bytes,
                   callback=None):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified register for
    the i2c device.


    :param address: i2c device address

    :param register: i2c register (or None if no register selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Optional callback function to report i2c data as a
               result of read command

    callback returns a data list:

    [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

    The pin_type for i2c = 6

    &#34;&#34;&#34;

    await self._i2c_read_request(address, register, number_of_bytes,
                                 PrivateConstants.I2C_READ, callback)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.i2c_read_continuous"><code class="name flex">
<span>async def <span class="ident">i2c_read_continuous</span></span>(<span>self, address, register, number_of_bytes, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Some i2c devices support a continuous streaming data output.
This command enables that mode for the device that supports
continuous reads.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Optional callback function to report i2c data as a
result of read command</p>
<p>callback returns a data list:</p>
<p>[pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]</p>
<p>The pin_type for i2c = 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def i2c_read_continuous(self, address, register, number_of_bytes,
                              callback=None):
    &#34;&#34;&#34;
    Some i2c devices support a continuous streaming data output.
    This command enables that mode for the device that supports
    continuous reads.


    :param address: i2c device address

    :param register: i2c register (or None if no register selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Optional callback function to report i2c data as a
               result of read command

    callback returns a data list:

    [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

    The pin_type for i2c = 6

    &#34;&#34;&#34;

    await self._i2c_read_request(address, register, number_of_bytes,
                                 PrivateConstants.I2C_READ_CONTINUOUSLY,
                                 callback)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.i2c_read_restart_transmission"><code class="name flex">
<span>async def <span class="ident">i2c_read_restart_transmission</span></span>(<span>self, address, register, number_of_bytes, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified register for
the i2c device. This restarts the transmission after the read. It is
required for some i2c devices such as the MMA8452Q accelerometer.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Optional callback function to report i2c data as a
result of read command</p>
<p>callback returns a data list:</p>
<p>[pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]</p>
<p>The pin_type for i2c = 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def i2c_read_restart_transmission(self, address, register,
                                        number_of_bytes,
                                        callback=None):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified register for
    the i2c device. This restarts the transmission after the read. It is
    required for some i2c devices such as the MMA8452Q accelerometer.


    :param address: i2c device address

    :param register: i2c register (or None if no register selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Optional callback function to report i2c data as a
               result of read command

    callback returns a data list:

    [pin_type, i2c_device_address, i2c_read_register, data_bytes returned, time_stamp]

    The pin_type for i2c = 6

    &#34;&#34;&#34;

    await self._i2c_read_request(address, register, number_of_bytes,
                                 PrivateConstants.I2C_READ
                                 | PrivateConstants.I2C_END_TX_MASK,
                                 callback)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.i2c_read_saved_data"><code class="name flex">
<span>async def <span class="ident">i2c_read_saved_data</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<div class="desc"><p>This method retrieves cached i2c data to support a polling mode.</p>
<p>:param address: I2C device address</p>
<p>:returns data: [raw data returned from i2c device, time-stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def i2c_read_saved_data(self, address):
    &#34;&#34;&#34;
    This method retrieves cached i2c data to support a polling mode.

    :param address: I2C device address

    :returns data: [raw data returned from i2c device, time-stamp]

    &#34;&#34;&#34;
    if address in self.i2c_map:
        map_entry = self.i2c_map.get(address)
        data = map_entry.get(&#39;value&#39;)
        return data
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.i2c_write"><code class="name flex">
<span>async def <span class="ident">i2c_write</span></span>(<span>self, address, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to an i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param args: A variable number of bytes to be sent to the device
passed in as a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def i2c_write(self, address, args):
    &#34;&#34;&#34;
    Write data to an i2c device.

    :param address: i2c device address

    :param args: A variable number of bytes to be sent to the device
                 passed in as a list

    &#34;&#34;&#34;
    data = [address, PrivateConstants.I2C_WRITE]
    for item in args:
        item_lsb = item &amp; 0x7f
        data.append(item_lsb)
        item_msb = (item &gt;&gt; 7) &amp; 0x7f
        data.append(item_msb)
    await self._send_sysex(PrivateConstants.I2C_REQUEST, data)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.keep_alive"><code class="name flex">
<span>async def <span class="ident">keep_alive</span></span>(<span>self, period=1, margin=0.3)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature.</p>
<p>Periodically send a keep alive message to the Arduino.</p>
<p>If the Arduino does not received a keep alive, the Arduino
will physically reset itself.</p>
<p>Frequency of keep alive transmission is calculated as follows:
keep_alive_sent = period - (period * margin)</p>
<p>:param period: Time period between keepalives. Range is 0-10 seconds.
0 disables the keepalive mechanism.</p>
<p>:param margin: Safety margin to assure keepalives are sent before
period expires. Range is 0.1 to 0.9</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def keep_alive(self, period=1, margin=.3):
    &#34;&#34;&#34;
    This is a FirmataExpress feature.

    Periodically send a keep alive message to the Arduino.

    If the Arduino does not received a keep alive, the Arduino
    will physically reset itself.

    Frequency of keep alive transmission is calculated as follows:
    keep_alive_sent = period - (period * margin)


    :param period: Time period between keepalives. Range is 0-10 seconds.
                   0 disables the keepalive mechanism.

    :param margin: Safety margin to assure keepalives are sent before
                period expires. Range is 0.1 to 0.9
    &#34;&#34;&#34;

    self.period = period
    self.margin = margin
    if period &lt; 0:
        period = 0

    # if there is a currently running keep alive task
    # and the the period is 0, kill the task and return
    if period == 0 and self.keep_alive_task:
        self.keep_alive_task.cancel()
        return

    self.keep_alive_interval = period &amp; 0x7f, (period &gt;&gt; 7) &amp; 0x7f
    # if there is no keep alive task, start one
    if not self.keep_alive_task:
        self.keep_alive_task = self.loop.create_task(
            self._send_keep_alive())</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.play_tone"><code class="name flex">
<span>async def <span class="ident">play_tone</span></span>(<span>self, pin_number, frequency, duration)</span>
</code></dt>
<dd>
<div class="desc"><p>This is FirmataExpress feature</p>
<p>Play a tone at the specified frequency for the specified duration.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param frequency: tone frequency in hz</p>
<p>:param duration: duration in milliseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def play_tone(self, pin_number, frequency, duration):
    &#34;&#34;&#34;

    This is FirmataExpress feature

    Play a tone at the specified frequency for the specified duration.

    :param pin_number: arduino pin number

    :param frequency: tone frequency in hz

    :param duration: duration in milliseconds

    &#34;&#34;&#34;
    await self._play_tone(pin_number, PrivateConstants.TONE_TONE, frequency=frequency,
                          duration=duration)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.play_tone_continuously"><code class="name flex">
<span>async def <span class="ident">play_tone_continuously</span></span>(<span>self, pin_number, frequency)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature</p>
<p>This method plays a tone continuously until play_tone_off is called.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param frequency: tone frequency in hz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def play_tone_continuously(self, pin_number, frequency):
    &#34;&#34;&#34;

    This is a FirmataExpress feature

    This method plays a tone continuously until play_tone_off is called.

    :param pin_number: arduino pin number

    :param frequency: tone frequency in hz

    &#34;&#34;&#34;

    await self._play_tone(pin_number, PrivateConstants.TONE_TONE, frequency=frequency,
                          duration=None)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.play_tone_off"><code class="name flex">
<span>async def <span class="ident">play_tone_off</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress Feature</p>
<p>This method turns tone off for the specified pin.</p>
<p>:param pin_number: arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def play_tone_off(self, pin_number):
    &#34;&#34;&#34;
    This is a FirmataExpress Feature

    This method turns tone off for the specified pin.

    :param pin_number: arduino pin number

    &#34;&#34;&#34;

    await self._play_tone(pin_number, PrivateConstants.TONE_NO_TONE,
                          frequency=None, duration=None)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.pwm_write"><code class="name flex">
<span>async def <span class="ident">pwm_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an alias for PWM_write
Set the selected pin to the specified value.</p>
<p>:param pin: PWM pin number</p>
<p>:param value: Pin value (0 - 0x4000)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def pwm_write(self, pin, value):
    &#34;&#34;&#34;
    This is an alias for PWM_write
    Set the selected pin to the specified value.

    :param pin: PWM pin number

    :param value: Pin value (0 - 0x4000)

    &#34;&#34;&#34;
    if PrivateConstants.ANALOG_MESSAGE + pin &lt; 0xf0:
        command = [PrivateConstants.ANALOG_MESSAGE + pin, value &amp; 0x7f,
                   (value &gt;&gt; 7) &amp; 0x7f]
        await self._send_command(command)
    else:
        await self._analog_write_extended(pin, value)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.send_reset"><code class="name flex">
<span>async def <span class="ident">send_reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a Sysex reset command to the arduino</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_reset(self):
    &#34;&#34;&#34;
    Send a Sysex reset command to the arduino

    &#34;&#34;&#34;
    try:
        await self._send_command([PrivateConstants.SYSTEM_RESET])
    except RuntimeError:
        raise</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.servo_write"><code class="name flex">
<span>async def <span class="ident">servo_write</span></span>(<span>self, pin, position)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an alias for pwm_write to set
the position of a servo that has been
previously configured using set_pin_mode_servo.</p>
<p>:param pin: arduino pin number</p>
<p>:param position: servo position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def servo_write(self, pin, position):
    &#34;&#34;&#34;
    This is an alias for pwm_write to set
    the position of a servo that has been
    previously configured using set_pin_mode_servo.

    :param pin: arduino pin number

    :param position: servo position

    &#34;&#34;&#34;

    await self.pwm_write(pin, position)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_analog_input"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_analog_input</span></span>(<span>self, pin_number, callback=None, differential=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as an analog input.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: async callback function</p>
<p>:param differential: This value needs to be met for a callback
to be invoked.</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for analog input pins = 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_analog_input(self, pin_number, callback=None,
                                    differential=1):
    &#34;&#34;&#34;
    Set a pin as an analog input.

    :param pin_number: arduino pin number

    :param callback: async callback function

    :param differential: This value needs to be met for a callback
                         to be invoked.

    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for analog input pins = 2

    &#34;&#34;&#34;
    await self._set_pin_mode(pin_number, PrivateConstants.ANALOG,
                             callback=callback,
                             differential=differential)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_dht"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_dht</span></span>(<span>self, pin_number, sensor_type=22, differential=0.1, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure a DHT sensor prior to operation.
Up to 6 DHT sensors are supported</p>
<p>:param pin_number: digital pin number on arduino.</p>
<p>:param sensor_type: type of dht sensor
Valid values = DHT11, DHT22,</p>
<p>:param differential: This value needs to be met for a callback
to be invoked.</p>
<p>:param callback: callback function</p>
<p>callback: returns a data list:</p>
<p>[pin_type, pin_number, DHT type, validation flag, humidity value, temperature
raw_time_stamp]</p>
<p>The pin_type for DHT input pins = 15</p>
<p>Validation Flag Values:</p>
<pre><code>No Errors = 0

Checksum Error = 1

Timeout Error = 2

Invalid Value = 999
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_dht(self, pin_number, sensor_type=22, differential=.1,
                           callback=None):
    &#34;&#34;&#34;
    Configure a DHT sensor prior to operation.
    Up to 6 DHT sensors are supported

    :param pin_number: digital pin number on arduino.

    :param sensor_type: type of dht sensor
                        Valid values = DHT11, DHT22,

    :param differential: This value needs to be met for a callback
                         to be invoked.

    :param callback: callback function

    callback: returns a data list:

    [pin_type, pin_number, DHT type, validation flag, humidity value, temperature
    raw_time_stamp]

    The pin_type for DHT input pins = 15

    Validation Flag Values:

        No Errors = 0

        Checksum Error = 1

        Timeout Error = 2

        Invalid Value = 999
    &#34;&#34;&#34;

    # if the pin is not currently associated with a DHT device
    # initialize it.
    if pin_number not in self.dht_list:
        self.dht_list.append(pin_number)
        self.digital_pins[pin_number].cb = callback
        self.digital_pins[pin_number].current_value = [0, 0]
        self.digital_pins[pin_number].differential = differential
        data = [pin_number, sensor_type]
        await self._send_sysex(PrivateConstants.DHT_CONFIG, data)
    else:
        # allow user to change the differential value
        self.digital_pins[pin_number].differential = differential</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_input"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_digital_input</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: async callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins = 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_digital_input(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input.

    :param pin_number: arduino pin number

    :param callback: async callback function

    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins = 0

    &#34;&#34;&#34;
    await self._set_pin_mode(pin_number, PrivateConstants.INPUT, callback)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_input_pullup"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_digital_input_pullup</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input with pullup enabled.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: async callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins with pullups enabled = 11</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input with pullup enabled.

    :param pin_number: arduino pin number

    :param callback: async callback function

    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins with pullups enabled = 11

    &#34;&#34;&#34;
    await self._set_pin_mode(pin_number, PrivateConstants.PULLUP, callback)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_output"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_digital_output</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital output pin.</p>
<p>:param pin_number: arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_digital_output(self, pin_number):
    &#34;&#34;&#34;
    Set a pin as a digital output pin.

    :param pin_number: arduino pin number
    &#34;&#34;&#34;

    await self._set_pin_mode(pin_number, PrivateConstants.OUTPUT)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_i2c"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_i2c</span></span>(<span>self, read_delay_time=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish the standard Arduino i2c pins for i2c utilization.</p>
<p>NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
This method initializes Firmata for I2c operations.</p>
<p>:param read_delay_time (in microseconds): an optional parameter,
default is 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_i2c(self, read_delay_time=0):
    &#34;&#34;&#34;
    Establish the standard Arduino i2c pins for i2c utilization.

    NOTE: THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
    This method initializes Firmata for I2c operations.

    :param read_delay_time (in microseconds): an optional parameter,
                                              default is 0

    &#34;&#34;&#34;
    data = [read_delay_time &amp; 0x7f, (read_delay_time &gt;&gt; 7) &amp; 0x7f]
    await self._send_sysex(PrivateConstants.I2C_CONFIG, data)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_pwm"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_pwm</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an alias for set_pin_mode_pwm_output.</p>
<p>Set a pin as a pwm (analog output) pin.</p>
<p>:param pin_number:arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_pwm(self, pin_number):
    &#34;&#34;&#34;

    This is an alias for set_pin_mode_pwm_output.

    Set a pin as a pwm (analog output) pin.

    :param pin_number:arduino pin number

    &#34;&#34;&#34;
    await self.set_pin_mode_pwm_output(pin_number)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_pwm_output"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_pwm_output</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a pwm (analog output) pin.</p>
<p>:param pin_number:arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_pwm_output(self, pin_number):
    &#34;&#34;&#34;
    Set a pin as a pwm (analog output) pin.

    :param pin_number:arduino pin number

    &#34;&#34;&#34;
    await self._set_pin_mode(pin_number, PrivateConstants.PWM)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_servo"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_servo</span></span>(<span>self, pin, min_pulse=544, max_pulse=2400)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure a pin as a servo pin. Set pulse min, max in ms.</p>
<p>:param pin: Servo Pin.</p>
<p>:param min_pulse: Min pulse width in ms.</p>
<p>:param max_pulse: Max pulse width in ms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_servo(self, pin, min_pulse=544, max_pulse=2400):
    &#34;&#34;&#34;
    Configure a pin as a servo pin. Set pulse min, max in ms.

    :param pin: Servo Pin.

    :param min_pulse: Min pulse width in ms.

    :param max_pulse: Max pulse width in ms.

    &#34;&#34;&#34;
    command = [pin, min_pulse &amp; 0x7f, (min_pulse &gt;&gt; 7) &amp; 0x7f,
               max_pulse &amp; 0x7f,
               (max_pulse &gt;&gt; 7) &amp; 0x7f]

    await self._send_sysex(PrivateConstants.SERVO_CONFIG, command)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_sonar"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_sonar</span></span>(<span>self, trigger_pin, echo_pin, callback=None, timeout=80000)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature.</p>
<p>Configure the pins,ping interval and maximum distance for an HC-SR04
type device.</p>
<p>Up to a maximum of 6 SONAR devices is supported.
If the maximum is exceeded a message is sent to the console and the
request is ignored.</p>
<p>NOTE: data is measured in centimeters</p>
<p>:param trigger_pin: The pin number of for the trigger (transmitter).</p>
<p>:param echo_pin: The pin number for the received echo.</p>
<p>:param callback: optional callback function to report sonar data changes</p>
<p>:param timeout: a tuning parameter. 80000UL equals 80ms.</p>
<p>callback returns a data list:</p>
<p>[pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]</p>
<p>The pin_type for sonar pins = 12</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                             callback=None, timeout=80000):
    &#34;&#34;&#34;
    This is a FirmataExpress feature.

    Configure the pins,ping interval and maximum distance for an HC-SR04
    type device.

    Up to a maximum of 6 SONAR devices is supported.
    If the maximum is exceeded a message is sent to the console and the
    request is ignored.

    NOTE: data is measured in centimeters

    :param trigger_pin: The pin number of for the trigger (transmitter).

    :param echo_pin: The pin number for the received echo.

    :param callback: optional callback function to report sonar data changes

    :param timeout: a tuning parameter. 80000UL equals 80ms.

    callback returns a data list:

    [pin_type, trigger_pin_number, distance_value (in cm), raw_time_stamp]

    The pin_type for sonar pins = 12


    &#34;&#34;&#34;
    # if there is an entry for the trigger pin in existence,
    # ignore the duplicate request.
    if trigger_pin in self.active_sonar_map:
        return

    timeout_lsb = timeout &amp; 0x7f
    timeout_msb = (timeout &gt;&gt; 7) &amp; 0x7f
    data = [trigger_pin, echo_pin, timeout_lsb,
            timeout_msb]

    await self._set_pin_mode(trigger_pin, PrivateConstants.SONAR,
                             PrivateConstants.INPUT)
    await self._set_pin_mode(echo_pin, PrivateConstants.SONAR,
                             PrivateConstants.INPUT)
    # update the ping data map for this pin
    if len(self.active_sonar_map) &gt; 6:
        print(&#39;sonar_config: maximum number of devices assigned&#39;
              &#39; - ignoring request&#39;)
    else:
        self.active_sonar_map[trigger_pin] = [callback, 0, 0]

    await self._send_sysex(PrivateConstants.SONAR_CONFIG, data)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_stepper"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_stepper</span></span>(<span>self, steps_per_revolution, stepper_pins)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature.</p>
<p>Configure stepper motor prior to operation.
This is a FirmataPlus feature.</p>
<p>NOTE: Single stepper only. Multiple steppers not supported.</p>
<p>:param steps_per_revolution: number of steps per motor revolution</p>
<p>:param stepper_pins: a list of control pin numbers - either 4 or 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_stepper(self, steps_per_revolution, stepper_pins):
    &#34;&#34;&#34;
    This is a FirmataExpress feature.

    Configure stepper motor prior to operation.
    This is a FirmataPlus feature.

    NOTE: Single stepper only. Multiple steppers not supported.

    :param steps_per_revolution: number of steps per motor revolution

    :param stepper_pins: a list of control pin numbers - either 4 or 2

    &#34;&#34;&#34;
    data = [PrivateConstants.STEPPER_CONFIGURE,
            steps_per_revolution &amp; 0x7f,
            (steps_per_revolution &gt;&gt; 7) &amp; 0x7f]
    for pin in range(len(stepper_pins)):
        data.append(stepper_pins[pin])
    await self._send_sysex(PrivateConstants.STEPPER_DATA, data)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_pin_mode_tone"><code class="name flex">
<span>async def <span class="ident">set_pin_mode_tone</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>This is FirmataExpress feature.</p>
<p>Set a PWM pin to tone mode.</p>
<p>:param pin_number: arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_pin_mode_tone(self, pin_number):
    &#34;&#34;&#34;
    This is FirmataExpress feature.

    Set a PWM pin to tone mode.

    :param pin_number: arduino pin number

    &#34;&#34;&#34;
    command = [PrivateConstants.SET_PIN_MODE, pin_number,
               PrivateConstants.TONE]
    await self._send_command(command)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.set_sampling_interval"><code class="name flex">
<span>async def <span class="ident">set_sampling_interval</span></span>(<span>self, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>This method sends the desired sampling interval to Firmata.</p>
<p>Note: Standard Firmata
will ignore any interval less than
10 milliseconds</p>
<p>:param interval: Integer value for desired sampling interval
in milliseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_sampling_interval(self, interval):
    &#34;&#34;&#34;
    This method sends the desired sampling interval to Firmata.

    Note: Standard Firmata  will ignore any interval less than
          10 milliseconds

    :param interval: Integer value for desired sampling interval
                     in milliseconds

    &#34;&#34;&#34;
    data = [interval &amp; 0x7f, (interval &gt;&gt; 7) &amp; 0x7f]
    await self._send_sysex(PrivateConstants.SAMPLING_INTERVAL, data)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.shutdown"><code class="name flex">
<span>async def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method attempts an orderly shutdown
If any exceptions are thrown, they are ignored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shutdown(self):
    &#34;&#34;&#34;
    This method attempts an orderly shutdown
    If any exceptions are thrown, they are ignored.

    &#34;&#34;&#34;

    self.shutdown_flag = True

    # stop all reporting - both analog and digital
    for pin in range(len(self.analog_pins)):
        await self.disable_analog_reporting(pin)

    for pin in range(len(self.digital_pins)):
        await self.disable_digital_reporting(pin)

    try:
        if self.close_loop_on_shutdown:
            self.loop.stop()
        await self.send_reset()
        await self.serial_port.reset_input_buffer()
        await self.serial_port.close()
        if self.close_loop_on_shutdown:
            self.loop.close()
    except (RuntimeError, SerialException):
        pass</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.sonar_read"><code class="name flex">
<span>async def <span class="ident">sonar_read</span></span>(<span>self, trigger_pin)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature</p>
<p>Retrieve Ping (HC-SR04 type) data. The data is presented as a
dictionary.</p>
<p>The 'key' is the trigger pin specified in sonar_config()
and the 'data' is the current measured distance (in centimeters)
for that pin. If there is no data, the value is set to None.</p>
<p>:param trigger_pin: key into sonar data map</p>
<p>:returns: [last distance, raw time stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def sonar_read(self, trigger_pin):
    &#34;&#34;&#34;
    This is a FirmataExpress feature

    Retrieve Ping (HC-SR04 type) data. The data is presented as a
    dictionary.

    The &#39;key&#39; is the trigger pin specified in sonar_config()
    and the &#39;data&#39; is the current measured distance (in centimeters)
    for that pin. If there is no data, the value is set to None.

    :param trigger_pin: key into sonar data map

    :returns: [last distance, raw time stamp]
    &#34;&#34;&#34;

    sonar_pin_entry = self.active_sonar_map.get(trigger_pin)
    return [sonar_pin_entry[1], sonar_pin_entry[2]]</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.start_aio"><code class="name flex">
<span>async def <span class="ident">start_aio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method may be called directly, if the autostart
parameter in <strong>init</strong> is set to false.</p>
<p>This method instantiates the serial interface and then performs auto pin
discovery if using a serial interface, or creates and connects to
a TCP/IP enabled device running StandardFirmataWiFi.</p>
<p>Use this method if you wish to start PymataExpress manually from
an asyncio function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start_aio(self):
    &#34;&#34;&#34;
    This method may be called directly, if the autostart
    parameter in __init__ is set to false.

    This method instantiates the serial interface and then performs auto pin
    discovery if using a serial interface, or creates and connects to
    a TCP/IP enabled device running StandardFirmataWiFi.

    Use this method if you wish to start PymataExpress manually from
    an asyncio function.
     &#34;&#34;&#34;

    # using the serial port
    if not self.ip_address:
        if not self.com_port:
            # user did not specify a com_port
            try:
                await self._find_arduino()
            except KeyboardInterrupt:
                if self.shutdown_on_exception:
                    await self.shutdown()
        else:
            # com_port specified - set com_port and baud rate
            try:
                await self._manual_open()
            except KeyboardInterrupt:
                if self.shutdown_on_exception:
                    await self.shutdown()

        if self.com_port:
            print(&#39;{}{}\n&#39;.format(&#39;\nArduino found and connected to &#39;,
                                  self.com_port))

        # no com_port found - raise a runtime exception
        else:
            if self.shutdown_on_exception:
                await self.shutdown()
            raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)
    # connect to a wifi enabled device server
    else:
        self.socket_transport = PymataExpressSocket(self.ip_address, self.ip_port,
                                                    self.loop)
        await self.socket_transport.start()
        # self.loop.create_task(self.socket_transport.read())

    # start the command dispatcher loop
    if not self.loop:
        self.loop = asyncio.get_event_loop()
    self.the_task = self.loop.create_task(self._arduino_report_dispatcher())

    # get arduino firmware version and print it
    firmware_version = await self.get_firmware_version()
    if not firmware_version:
        print(&#39;*** Firmware Version retrieval timed out. ***&#39;)
        print(&#39;\nDo you have Arduino connectivity and do you have a &#39;)
        print(&#39;Firmata sketch uploaded to the board and are connected&#39;)
        print(&#39;to the correct serial port.\n&#39;)
        print(&#39;To see a list of serial ports, type: &#39;
              &#39;&#34;list_serial_ports&#34; in your console.&#39;)
        if self.shutdown_on_exception:
            await self.shutdown()
        raise RuntimeError
    else:
        if self.using_firmata_express:
            version_number = firmware_version[0:3]
            if version_number != PrivateConstants.FIRMATA_EXPRESS_VERSION:
                raise RuntimeError(f&#39;You must use FirmataExpress version 1.2. &#39;
                                   f&#39;Version Found = {version_number}&#39;)
        print(&#34;\nArduino Firmware ID: &#34; + firmware_version)

    # try to get an analog pin map. if it comes back as none - shutdown
    report = await self.get_analog_map()
    if not report:
        print(&#39;*** Analog map retrieval timed out. ***&#39;)
        print(&#39;\nDo you have Arduino connectivity and do you have a &#39;
              &#39;Firmata sketch uploaded to the board?&#39;)
        if self.shutdown_on_exception:
            await self.shutdown()
        raise RuntimeError

    # custom assemble the pin lists
    for pin in report:
        digital_data = PinData()
        self.digital_pins.append(digital_data)
        if pin != PrivateConstants.IGNORE:
            analog_data = PinData()
            self.analog_pins.append(analog_data)

    print(&#39;{} {} {} {} {}&#39;.format(&#39;Auto-discovery complete. Found&#39;,
                                  len(self.digital_pins),
                                  &#39;Digital Pins and&#39;,
                                  len(self.analog_pins),
                                  &#39;Analog Pins\n\n&#39;))
    self.first_analog_pin = len(self.digital_pins) - len(self.analog_pins)
    await self.set_sampling_interval(19)</code></pre>
</details>
</dd>
<dt id="pymata_express.pymata_express.PymataExpress.stepper_write"><code class="name flex">
<span>async def <span class="ident">stepper_write</span></span>(<span>self, motor_speed, number_of_steps)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a FirmataExpress feature</p>
<p>Move a stepper motor for the number of steps at the specified speed.
This is a FirmataPlus feature.</p>
<p>:param motor_speed: 21 bits of data to set motor speed</p>
<p>:param number_of_steps: 14 bits for number of steps &amp; direction
positive is forward, negative is reverse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stepper_write(self, motor_speed, number_of_steps):
    &#34;&#34;&#34;
    This is a FirmataExpress feature

    Move a stepper motor for the number of steps at the specified speed.
    This is a FirmataPlus feature.

    :param motor_speed: 21 bits of data to set motor speed

    :param number_of_steps: 14 bits for number of steps &amp; direction
                            positive is forward, negative is reverse

    &#34;&#34;&#34;
    if number_of_steps &gt; 0:
        direction = 1
    else:
        direction = 0
    abs_number_of_steps = abs(number_of_steps)
    data = [PrivateConstants.STEPPER_STEP, motor_speed &amp; 0x7f,
            (motor_speed &gt;&gt; 7) &amp; 0x7f, (motor_speed &gt;&gt; 14) &amp; 0x7f,
            abs_number_of_steps &amp; 0x7f, (abs_number_of_steps &gt;&gt; 7) &amp; 0x7f,
            direction]
    await self._send_sysex(PrivateConstants.STEPPER_DATA, data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pymata_express" href="index.html">pymata_express</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pymata_express.pymata_express.PymataExpress" href="#pymata_express.pymata_express.PymataExpress">PymataExpress</a></code></h4>
<ul class="">
<li><code><a title="pymata_express.pymata_express.PymataExpress.analog_read" href="#pymata_express.pymata_express.PymataExpress.analog_read">analog_read</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.analog_write" href="#pymata_express.pymata_express.PymataExpress.analog_write">analog_write</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.dht_read" href="#pymata_express.pymata_express.PymataExpress.dht_read">dht_read</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.digital_pin_write" href="#pymata_express.pymata_express.PymataExpress.digital_pin_write">digital_pin_write</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.digital_read" href="#pymata_express.pymata_express.PymataExpress.digital_read">digital_read</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.digital_write" href="#pymata_express.pymata_express.PymataExpress.digital_write">digital_write</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.disable_analog_reporting" href="#pymata_express.pymata_express.PymataExpress.disable_analog_reporting">disable_analog_reporting</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.disable_digital_reporting" href="#pymata_express.pymata_express.PymataExpress.disable_digital_reporting">disable_digital_reporting</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.enable_analog_reporting" href="#pymata_express.pymata_express.PymataExpress.enable_analog_reporting">enable_analog_reporting</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.enable_digital_reporting" href="#pymata_express.pymata_express.PymataExpress.enable_digital_reporting">enable_digital_reporting</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.get_analog_map" href="#pymata_express.pymata_express.PymataExpress.get_analog_map">get_analog_map</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.get_capability_report" href="#pymata_express.pymata_express.PymataExpress.get_capability_report">get_capability_report</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.get_event_loop" href="#pymata_express.pymata_express.PymataExpress.get_event_loop">get_event_loop</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.get_firmware_version" href="#pymata_express.pymata_express.PymataExpress.get_firmware_version">get_firmware_version</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.get_pin_state" href="#pymata_express.pymata_express.PymataExpress.get_pin_state">get_pin_state</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.get_protocol_version" href="#pymata_express.pymata_express.PymataExpress.get_protocol_version">get_protocol_version</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.get_pymata_version" href="#pymata_express.pymata_express.PymataExpress.get_pymata_version">get_pymata_version</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.i2c_read" href="#pymata_express.pymata_express.PymataExpress.i2c_read">i2c_read</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.i2c_read_continuous" href="#pymata_express.pymata_express.PymataExpress.i2c_read_continuous">i2c_read_continuous</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.i2c_read_restart_transmission" href="#pymata_express.pymata_express.PymataExpress.i2c_read_restart_transmission">i2c_read_restart_transmission</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.i2c_read_saved_data" href="#pymata_express.pymata_express.PymataExpress.i2c_read_saved_data">i2c_read_saved_data</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.i2c_write" href="#pymata_express.pymata_express.PymataExpress.i2c_write">i2c_write</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.keep_alive" href="#pymata_express.pymata_express.PymataExpress.keep_alive">keep_alive</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.play_tone" href="#pymata_express.pymata_express.PymataExpress.play_tone">play_tone</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.play_tone_continuously" href="#pymata_express.pymata_express.PymataExpress.play_tone_continuously">play_tone_continuously</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.play_tone_off" href="#pymata_express.pymata_express.PymataExpress.play_tone_off">play_tone_off</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.pwm_write" href="#pymata_express.pymata_express.PymataExpress.pwm_write">pwm_write</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.send_reset" href="#pymata_express.pymata_express.PymataExpress.send_reset">send_reset</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.servo_write" href="#pymata_express.pymata_express.PymataExpress.servo_write">servo_write</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_analog_input" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_analog_input">set_pin_mode_analog_input</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_dht" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_dht">set_pin_mode_dht</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_input" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_input">set_pin_mode_digital_input</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_input_pullup" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_input_pullup">set_pin_mode_digital_input_pullup</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_output" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_digital_output">set_pin_mode_digital_output</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_i2c" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_i2c">set_pin_mode_i2c</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_pwm" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_pwm">set_pin_mode_pwm</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_pwm_output" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_pwm_output">set_pin_mode_pwm_output</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_servo" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_servo">set_pin_mode_servo</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_sonar" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_sonar">set_pin_mode_sonar</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_stepper" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_stepper">set_pin_mode_stepper</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_pin_mode_tone" href="#pymata_express.pymata_express.PymataExpress.set_pin_mode_tone">set_pin_mode_tone</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.set_sampling_interval" href="#pymata_express.pymata_express.PymataExpress.set_sampling_interval">set_sampling_interval</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.shutdown" href="#pymata_express.pymata_express.PymataExpress.shutdown">shutdown</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.sonar_read" href="#pymata_express.pymata_express.PymataExpress.sonar_read">sonar_read</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.start_aio" href="#pymata_express.pymata_express.PymataExpress.start_aio">start_aio</a></code></li>
<li><code><a title="pymata_express.pymata_express.PymataExpress.stepper_write" href="#pymata_express.pymata_express.PymataExpress.stepper_write">stepper_write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>